var tipuesearch = {"pages":[{"title":" BlockTran ","text":"BlockTran Developer Info Michael Hirsch Ph.D. SciVision, Inc.","tags":"home","loc":"index.html"},{"title":"main.f90 – BlockTran","text":"Contents Programs adder Source Code main.f90 Source Code program adder implicit none ( type , external ) interface integer function addone ( N ) bind ( C ) integer , intent ( in ), value :: N end function addone end interface if ( addone ( 2 ) /= 3 ) error stop \"unexpected addone result\" print * , \"OK: 2+1=3\" end program","tags":"","loc":"sourcefile/main.f90.html"},{"title":"ai.f90 – BlockTran","text":"Contents Modules AI Source Code ai.f90 Source Code module AI use fields , only : field use shapes , only : piece implicit none ( type , external ) contains subroutine AI_input ( F , P ) class ( field ), intent ( in ) :: F class ( piece ), intent ( inout ) :: P ! check if easy case--clear to bottom (FIXME: predict outcome) if ( project_down ( F , P ) >= F % H - P % Ny ) then call down_random ( P ) return endif ! harder cases call seek_deep ( F , P ) end subroutine AI_input integer function project_down ( F , P ) result ( y ) ! returns freezing Y position for this ONE piece X position class ( field ), intent ( in ) :: F class ( piece ), intent ( in ) :: P type ( piece ) :: T integer :: i , j , h ( 4 ) ! create test piece call T % init ( F , P % btype , x = P % x , y = P % y ) ! see how low the piece can go for this X position y = F % H h = 1 rot : do i = 1 , size ( h ) call T % rotate () hght : do j = 1 , F % H T % y = j if ( T % check_collision ()) then h ( i ) = j - 1 exit hght endif enddo hght enddo rot where ( h == 1 ) h = 9999 y = min ( y , maxval ( h )) end function project_down subroutine seek_deep ( F , P ) class ( field ), intent ( in ) :: F class ( piece ), intent ( inout ) :: P integer :: k ( 1 ), x_center , x_seek real :: r real , parameter :: dumbness = 0. ! 0..1  lower number, less dumb !-- maybe do something random instead of smart call random_number ( r ) if ( r < dumbness ) then ! act randomly instead call move_random ( P ) return endif !-- compute smarter action x_center = P % x - P % Nx / 2 ! FIXME: approximately, what about rotated \"I\" ! for now, seek the \"deepest\" place k = maxloc ( height ( F , P )) x_seek = k ( 1 ) !--- take action if ( x_seek <= x_center ) then call P % move_left () elseif ( x_seek >= x_center ) then call P % move_right () endif end subroutine seek_deep subroutine down_random ( P ) class ( piece ), intent ( inout ) :: P real :: r integer :: i call random_number ( r ) if ( r >= 0 . and . r < 0.25 ) then call random_number ( r ) do i = 1 , floor ( 2 * r ) call P % move_down () enddo elseif ( r >= 0.25 . and . r < 0.3 ) then call P % move_down ( slam = . true .) endif end subroutine down_random subroutine move_random ( P ) class ( piece ), intent ( inout ) :: P real :: r integer :: i real , parameter :: patience = 0.9 ! 0..1 if > patience, move. call random_number ( r ) if ( r < patience ) return call random_number ( r ) if ( r < 0.33 ) then call P % move_left () elseif ( r >= 0.33 . and . r < 0.66 ) then call P % move_right () else call P % rotate () call random_number ( r ) if ( r >= 0 . and . r < 0.25 ) then do i = 1 , floor ( 8 * r ) call P % move_left () enddo elseif ( r >= 0.25 . and . r < 0.5 ) then do i = 1 , floor ( 8 * r ) call P % move_right () enddo endif endif end subroutine move_random integer function height ( F , P ) ! \"Height\" is distance from top of screen -- smaller is higher ! checks how well piece fits class ( field ), intent ( in ) :: F class ( piece ), intent ( in ) :: P dimension :: height ( P % W ) integer :: i type ( piece ) :: T ! create test piece call T % init ( F , P % btype , x = P % x , y = P % y ) do i = 1 , F % W T % x = i height ( i ) = project_down ( F , T ) enddo where ( height == 1 ) height = 9999 end function height pure integer function diff ( A ) ! first difference integer , intent ( in ) :: A (:) dimension :: diff ( size ( A )) diff = A ( 2 :) - A (: size ( A ) - 1 ) end function diff end module AI","tags":"","loc":"sourcefile/ai.f90.html"},{"title":"blocks.f90 – BlockTran","text":"Contents Modules blocks Source Code blocks.f90 Source Code module blocks use cinter , only : mvaddch , endwin use shapes , only : Piece use fields , only : field implicit none ( type , external ) private public :: game_over , draw_piece , freeze contains subroutine draw_piece ( P ) class ( piece ), intent ( in ) :: P integer :: i , j , x , y ! not concurrent since \"mvaddch\" remembers its position do i = 1 , P % Ny y = ( i - 1 ) + P % y if ( y < 0 ) cycle do j = 1 , P % Nx x = ( j - 1 ) + P % x if ( P % values ( i , j ) /= 0 ) then ! zero-indexed, so another -1 call mvaddch ( y = y - 1 , x = ( P % x0 - 1 ) + x - 1 , & ch = P % ch ( P % values ( i , j ))) endif end do end do end subroutine draw_piece subroutine freeze ( F , P , NP ) ! Called when a piece has hit another and freezes class ( piece ), intent ( inout ) :: P , NP class ( field ), intent ( inout ) :: F integer :: i , y , ix , x , Nx , ixs character ( 120 ) :: buf if (. not . P % landed ) return x = P % x Nx = P % Nx ! not concurrent due to impure \"game over\" ix = max ( 1 , x ) ixs = min ( F % W , ix + Nx - ( ix - x ) - 1 ) do i = 1 , P % Ny if ( all ( P % values ( i , :) == 0 )) cycle y = i - 1 + P % y if ( y <= 1 ) then write ( buf , '(A12,I3,A3,I3)' ) 'freeze: x=' , x , 'y=' , y call game_over ( F , P , buf ) endif where ( F % screen ( y , ix : ixs ) == 1 . or . P % values ( i , ix - x + 1 : ixs - x + 1 ) == 1 ) F % screen ( y , ix : ixs ) = 1 endwhere end do call F % clear_lines () call P % spawn_block ( F , NP ) end subroutine freeze subroutine game_over ( F , P , msg ) class ( field ), intent ( in ) :: F class ( piece ), intent ( in ), optional :: P character ( * ), intent ( in ), optional :: msg integer :: i call endwin () do i = 1 , size ( F % screen , 1 ) print '(100I1)' , F % screen ( i ,:) enddo if ( present ( P )) print * , P % why if ( present ( msg )) print * , msg print * , ' ' print * , 'Level:' , F % level Print * , 'Score:' , F % score print * , 'Number of Blocks:' , F % Nblock print * , 'Number of Lines Cleared:' , F % Ncleared print * , 'Block Sequence: ' , F % blockseq (: F % Nblock ) if ( F % debug ) then write ( F % udbg , * ) 'Block Sequence: ' , F % blockseq (: F % Nblock ) close ( F % udbg ) endif stop 'Goodbye from Tetran' end subroutine game_over end module blocks","tags":"","loc":"sourcefile/blocks.f90.html"},{"title":"cinter.f90 – BlockTran","text":"Contents Modules cinter Source Code cinter.f90 Source Code module cinter use , intrinsic :: iso_c_binding , only : c_int , c_char , c_ptr , c_bool use oscinter , only : kbhit implicit none ( type , external ) integer ( c_int ) :: LINES , COLS type ( c_ptr ) :: stdscr , curscr integer ( c_int ), parameter :: FAIL = - 1 interface !--- function that use cinter.c ! http://www.urbanjost.altervista.org/LIBRARY/libscreen/ncurses/pdsrc/ncurses_from_Fortran.html function f_initscr () result ( initscr__OUT ) bind ( C , name = 'initscr' ) import type ( c_ptr ) :: initscr__OUT ! WINDOW *initscr end function f_initscr subroutine getmaxyx ( win , y , x ) bind ( C , name = 'macro_getmaxyx' ) import type ( c_ptr ), value :: win integer ( c_int ) :: y , x end subroutine getmaxyx !--- functions that interface directly with Curses subroutine endwin () bind ( C ) ! ncurses restores previous terminal contents (before program was run) end subroutine endwin integer ( c_int ) function getch () result ( ch ) bind ( C ) import end function getch subroutine flushinp () bind ( c ) end subroutine flushinp subroutine timeout ( delay ) bind ( C ) !! timeout(0) => non-blocking getch() (-1 if no keypress) import integer ( c_int ), value :: delay end subroutine timeout function nodelay ( win , bf ) result ( ierr ) bind ( C , name = 'nodelay' ) !! http://www.urbanjost.altervista.org/LIBRARY/libscreen/ncurses/pdsrc/ncurses.f90 import INTEGER ( C_INT ) :: ierr type ( C_PTR ) , value :: win ! const WINDOW *win logical ( C_BOOL ) , value :: bf ! bool bf end function nodelay function keypad ( win , bf ) result ( ierr ) bind ( C , name = 'keypad' ) !! http://www.urbanjost.altervista.org/LIBRARY/libscreen/ncurses/pdsrc/ncurses.f90 import INTEGER ( C_INT ) :: ierr ! int keypad type ( C_PTR ) , value :: win ! const WINDOW *win logical ( C_BOOL ) , value :: bf ! bool bf end function keypad !-------------------- integer ( c_int ) function f_addch ( ch ) result ( addch__OUT ) bind ( c , name = 'addch' ) import character ( kind = c_char ) , value , intent ( in ) :: ch end function f_addch subroutine mvaddch ( y , x , ch ) bind ( C , name = 'mvaddch' ) import integer ( c_int ), intent ( in ), value :: y , x character ( kind = c_char ), intent ( in ), value :: ch end subroutine mvaddch subroutine refresh () bind ( C ) end subroutine refresh subroutine clear () bind ( C ) !! clear entire screen end subroutine clear subroutine border () bind ( C ) !! draw border end subroutine border subroutine noecho () bind ( C ) ! don't echo keypresses to screen end subroutine noecho subroutine cbreak () bind ( C ) ! disable line buffer end subroutine cbreak subroutine mvprintw ( y , x , str ) bind ( C ) import integer ( c_int ), intent ( in ), value :: y , x character ( kind = c_char ), intent ( in ) :: str end subroutine mvprintw integer ( c_int ) function printw ( str ) bind ( C ) import character ( kind = c_char ), intent ( in ) :: str end function printw end interface contains function initscr () result ( stdscr__OUT ) ! call initscr() but set global variables too ! http://www.urbanjost.altervista.org/LIBRARY/libscreen/ncurses/pdsrc/ncurses_from_Fortran.html type ( C_PTR ) :: stdscr__OUT stdscr = f_initscr () !stdscr=returnstd() !curscr=returncur() stdscr__OUT = stdscr call getmaxyx ( stdscr , LINES , COLS ) if ( LINES < 0 ) error stop 'Curses: could not get LINES' if ( COLS < 0 ) error stop 'Curses: could not get COLS' end function initscr subroutine addch ( ch ) character ( kind = c_char ), value , intent ( in ) :: ch !< const chtype ch integer ( c_int ) :: ierr ierr = f_addch ( ch ) if ( ierr == FAIL ) error stop 'addch' end subroutine addch end module cinter","tags":"","loc":"sourcefile/cinter.f90.html"},{"title":"err.f90 – BlockTran","text":"Contents Modules errs Source Code err.f90 Source Code module errs use , intrinsic :: iso_fortran_env , only : error_unit use cinter , only : endwin implicit none ( type , external ) contains subroutine err ( msg ) character ( * ), intent ( in ) :: msg call endwin () write ( error_unit , * ) msg error stop end subroutine err end module","tags":"","loc":"sourcefile/err.f90.html"},{"title":"fields.f90 – BlockTran","text":"Contents Modules fields Source Code fields.f90 Source Code module fields use , intrinsic :: iso_c_binding , only : c_int implicit none ( type , external ) private type , public :: Field ! Microseconds between each automatic downward move real :: move_time = 0.5 ! seconds integer ( c_int ) :: sleep_incr = 50 !  keyboard polling and screen refresh interval (milliseconds). ! 1e6 microsec: mushy controls. 1e5 microsec a little laggy. 5e4 about right. 1e4 microsec screen flicker. real :: difffact = 1. integer :: level = 1 real :: diffinc = 1.2 ! factor by which level jumps difficulty integer :: score = 0 integer :: Nblock = 0 integer :: Ncleared = 0 ! total number of lines cleared integer :: lines_per_level = 10 ! how many lines to clear to advance to next level integer :: bonus ( - 1 : 4 ) = [ - 100 , 0 , 40 , 100 , 300 , 1200 ] character ( 1 ) :: blockseq ( 10000 ) = \"\" ! record of blocks player experienced ! NOTE: uses eoshift to avoid indexing beyond array, discarding earliest turns integer :: toc , tic ! for each field's update time tracking integer :: H , W ! playfield height, width integer :: x0 ! master horizontal origin display coordinate for each playfield ! Playfield: 0 for blank integer , allocatable :: screen (:,:) logical :: debug = . false . integer :: udbg logical :: newhit = . false . logical :: cheat = . false . logical :: AI contains procedure , public :: setup , levelup , clear_lines end type contains subroutine setup ( self , W , H , x0 , AI , difffact , debug ) class ( Field ), intent ( inout ) :: self integer , intent ( in ) :: H , W integer , intent ( in ), optional :: x0 logical , intent ( in ), optional :: AI real , intent ( in ), optional :: difffact logical , intent ( in ), optional :: debug self % H = H self % W = W self % x0 = 1 if ( present ( x0 )) self % x0 = x0 self % AI = . false . if ( present ( AI )) self % AI = AI if ( present ( difffact )) self % difffact = difffact if ( present ( debug )) self % debug = debug allocate ( self % screen ( self % H , self % W )) self % screen = 0 end subroutine setup subroutine levelup ( self ) class ( field ), intent ( inout ) :: self self % newhit = . false . self % level = self % level + 1 self % difffact = self % difffact * self % diffinc self % move_time = self % move_time / self % difffact end subroutine levelup subroutine clear_lines ( self ) class ( field ), intent ( inout ) :: self logical :: lines_to_clear ( self % H ) integer :: i , counter lines_to_clear = all ( self % screen == 1 , 2 ) ! mask of lines that need clearing counter = count ( lines_to_clear ) ! how many lines are cleared if ( counter == 0 ) return if ( self % cheat ) then counter = - 1 ! penalty self % cheat = . false . endif self % Ncleared = self % Ncleared + counter if ( self % debug ) write ( self % udbg , * ) lines_to_clear , counter self % score = self % score + self % bonus ( counter ) ! not concurrent since it could clear lines above shifted by other concurrent iterations ! i.e. in some cases, it would check an OK line that turns bad after clearing by another elemental iteration. ! also note non-adjacent lines can be cleared at once. do i = 1 , self % H if (. not . lines_to_clear ( i )) cycle self % newhit = . true . self % screen ( i ,:) = 0 ! wipe away cleared lines self % screen (: i , :) = cshift ( self % screen (: i , :), shift =- 1 , dim = 1 ) ! Bring everything down end do end subroutine clear_lines end module fields","tags":"","loc":"sourcefile/fields.f90.html"},{"title":"game.f90 – BlockTran","text":"Contents Modules game Source Code game.f90 Source Code module game use , intrinsic :: iso_c_binding , only : c_ptr , c_bool , c_int use menu , only : title use cinter , only : initscr , noecho , mvprintw , mvaddch , & clear , timeout , cbreak , keypad , endwin , refresh , & maxH => LINES , maxW => COLS use sleep_std , only : sleep use errs , only : err use blocks , only : freeze , draw_piece use shapes , only : piece use fields , only : field use random , only : randint use keys , only : key_input implicit none ( type , external ) type ( field ) :: F ( 2 ) integer :: trate !< elapsed time integer :: players logical :: update = . false . logical :: debug = . false . real :: difffact contains subroutine main_game ( W , H ) integer , intent ( in ) :: H , W type ( c_ptr ) :: stdscr type ( piece ) :: P ( 2 ), NP ( 2 ) integer ( c_int ) :: ierr integer :: x0 ( 2 ) integer :: i logical , parameter :: isAI ( 2 ) = [. false ., . true .] logical ( c_bool ), parameter :: true = . true . !> get tick rae call system_clock ( count_rate = trate ) !> initialize Curses stdscr = initscr () ! Game Playfield too big if ( H + 3 > maxH ) call err ( 'playfield height too tall for terminal window' ) if ( W + 10 > maxW ) call err ( 'playfield width too wide for terminal window' ) x0 = [ 1 , W + 15 ] call noecho () call cbreak () call timeout ( 0 ) ierr = keypad ( stdscr , true ) !--- show title screen call title () !--- begin game do i = 1 , players call F ( i )% setup ( W = W , H = H , x0 = x0 ( i ), AI = isAI ( i ), difffact = difffact , debug = debug ) !--- create first block call NP ( i )% init ( F ( i )) call P ( i )% spawn_block ( F ( i ), NP ( i )) call redraw ( F ( i ), P ( i ), NP ( i )) call system_clock ( count = F ( i )% tic ) enddo !--------- main loop main : do do i = 1 , players call mainsub ( F ( i ), P ( i ), NP ( i )) end do if ( update ) then !call clear() do i = 1 , players call redraw ( F ( i ), P ( i ), NP ( i )) enddo update = . false . end if call sleep ( F ( 1 )% sleep_incr ) end do main end subroutine main_game subroutine mainsub ( F , P , NP ) class ( field ) :: F type ( piece ) :: P , NP call key_input ( F , P , NP ) ! was a key pressed? call freeze ( F , P , NP ) update = P % movereq call system_clock ( count = F % toc ) !    if(debug) print *,F%toc-F%tic, F%toc, F%tic  ! in lower right corder of screen if ( ( F % toc - F % tic ) / real ( trate ) > F % move_time ) then !! time's up, move piece one step down. real(trate) is necessary for float time comparison! update = . true . call P % move_down () call freeze ( F , P , NP ) if ( F % newhit ) then if ( modulo ( F % Ncleared , F % lines_per_level ) == 0 ) call F % levelup () endif call system_clock ( count = F % tic ) endif end subroutine mainsub subroutine redraw ( F , P , NP ) class ( field ), intent ( in ) :: F class ( piece ), intent ( in ) :: P , NP call draw_screen ( F ) ! Draw the falling block call draw_piece ( P ) ! Draw next block call draw_piece ( NP ) call draw_score ( F ) call refresh () end subroutine redraw subroutine cmd_parse ( W , H ) ! reads flag command line arguments integer , intent ( out ) :: W , H integer :: i , argc character ( * ), parameter :: logfn = 'blocktran.log' character ( 32 ) :: arg character ( 8 ) :: date character ( 10 ) :: time ! --- default values W = randint ( 10 , 15 ) H = randint ( 15 , 20 ) difffact = 1. players = 1 debug = . false . ! --- process options argc = command_argument_count () do i = 1 , argc call get_command_argument ( i , arg ) select case ( arg ) case ( '-s' , '--size' ) ! set playfield size call get_command_argument ( i + 1 , arg ) read ( arg , '(I3)' ) W call get_command_argument ( i + 2 , arg ) read ( arg , '(I3)' ) H if ( H < 6 . or . W < 6 ) call err ( 'Height and width must each be at least 6' ) case ( '-d' , '--difficulty' ) call get_command_argument ( i + 1 , arg ) read ( arg , '(F4.1)' ) difffact if ( difffact <= 0 ) call err ( 'difficulty must be > 0' ) case ( '-p' , '--players' ) call get_command_argument ( i + 1 , arg ) read ( arg , '(I1)' ) players if ( players > 2 . or . players < 1 ) call err ( 'only 1 or 2 players' ) case ( '--debug' , '-v' , '--verbose' ) debug = . true . print * , 'debug enabled, writing to ' , logfn open ( newunit = F ( 1 )% udbg , file = logfn , action = 'Write' , & form = 'formatted' , status = 'unknown' , & position = 'append' ) call date_and_time ( date , time ) write ( F ( 1 )% udbg , * ) '--------------------------------------------' write ( F ( 1 )% udbg , * ) 'start: ' , date , 'T' , time write ( F ( 1 )% udbg , * ) 'Lines to clear                                 Counter' end select enddo end subroutine cmd_parse subroutine draw_screen ( F ) class ( field ), intent ( in ) :: F integer :: i , j ! not concurrent (and not where() ) since \"addch\" has memory of position do i = 1 , F % H do j = 1 , F % W select case ( F % screen ( i , j )) case ( 1 ) call mvaddch ( y = ( i - 1 ), x = F % x0 + ( j - 1 ) - 1 , ch = '@' ) ! frozen piece case ( 0 ) call mvaddch ( y = ( i - 1 ), x = F % x0 + ( j - 1 ) - 1 , ch = '.' ) ! background case default call err ( 'unknown screen state' ) end select end do end do end subroutine draw_screen subroutine draw_score ( F ) class ( field ), intent ( in ) :: F ! prints on line under bottom of playfield: !  score !  count of blocks played in this game character ( 16 ), save :: msg = \"\" ! this save variable is necessary to prevent garbage on screen write ( msg , \"(I10)\" ) F % score call mvprintw ( y = F % H , x = F % x0 + 0 , str = msg ) write ( msg , \"(I10)\" ) F % Nblock call mvprintw ( y = F % H + 1 , x = F % x0 + 0 , str = msg ) write ( msg , \"(I2)\" ) F % level call mvprintw ( y = F % H + 2 , x = F % x0 + 0 , str = msg ) write ( msg , \"(I4)\" ) F % Ncleared call mvprintw ( y = F % H + 2 , x = F % x0 + F % W - 4 , str = msg ) end subroutine draw_score end module game","tags":"","loc":"sourcefile/game.f90.html"},{"title":"keys.f90 – BlockTran","text":"Contents Modules keys Source Code keys.f90 Source Code module keys use , intrinsic :: iso_c_binding , only : c_int use ai , only : AI_input use cinter , only : getch , flushinp , kbhit , printw , endwin use blocks , only : game_over use shapes , only : piece use fields , only : field implicit none ( type , external ) contains subroutine key_input ( F , P , NP ) class ( field ), intent ( inout ) :: F class ( piece ), intent ( inout ) :: P class ( piece ), intent ( inout ), optional :: NP integer :: i !integer(c_int) :: ierr if ( P % landed ) then call endwin () error stop 'should not have requested input after landing' endif if ( F % AI ) then call AI_input ( F , P ) return endif if ( kbhit () /= 0 ) then ! ierr = printw('waiting on getch') i = getch () else i = - 1 endif ! keypad mode for arrow keys select case ( i ) case ( 259 ) i = iachar ( \"w\" ) case ( 260 ) i = iachar ( \"a\" ) case ( 258 ) i = iachar ( \"s\" ) case ( 261 ) i = iachar ( \"d\" ) end select P % movereq = . true . ! rather than typing it for each case select case ( i ) case ( iachar ( \"a\" )) ! A - left call P % move_left () case ( iachar ( \"l\" )) ! L - slam left call P % move_left ( slam = . true .) case ( iachar ( \"s\" )) ! S - down call P % move_down () case ( iachar ( \"x\" )) ! X - slam down call P % move_down ( slam = . true .) case ( iachar ( \"d\" )) ! D - right call P % move_right () case ( iachar ( \"r\" )) ! R - slam right call P % move_right ( slam = . true .) case ( iachar ( \"w\" )) ! W - rotate call P % rotate () case ( iachar ( \"v\" )) ! V - flip vertically call P % vertflip () case ( iachar ( \"h\" )) ! H - flip horizontally call P % horizflip () case ( iachar ( \"q\" )) ! Q - quit call game_over ( F ) case ( iachar ( \"t\" )) ! CHEAT   T - reset current piece position y to top, preserving x position P % y = 0 F % cheat = . true . case ( iachar ( \"n\" )) ! CHEAT    N - pick a new piece type for the NEXT block if ( present ( NP )) then call NP % init ( F , x = F % W + 5 , y = F % H / 2 ) endif F % cheat = . true . case ( iachar ( \"c\" )) ! CHEAT  C - clear lowest line (subtract 100 points as penalty) F % screen ( F % H ,:) = 1 call F % clear_lines () P % screen = F % screen ! since we didn't generate a new piece (alternatively, could have made a new piece right here) F % cheat = . true . case default ! do nothing P % movereq = . false . end select call flushinp () ! clear repeating keys from stdin buffer end subroutine key_input end module keys","tags":"","loc":"sourcefile/keys.f90.html"},{"title":"main.f90 – BlockTran","text":"Contents Programs BlockTran Source Code main.f90 Source Code program BlockTran use random , only : rand_init use game , only : cmd_parse , main_game implicit none ( type , external ) integer :: W , H call rand_init (. false ., . false .) call cmd_parse ( W = W , H = H ) call main_game ( W = W , H = W ) end program","tags":"","loc":"sourcefile/main.f90~2.html"},{"title":"menu.f90 – BlockTran","text":"Contents Modules menu Source Code menu.f90 Source Code module menu use , intrinsic :: iso_c_binding , only : c_int , c_ptr use , intrinsic :: iso_fortran_env , only : stderr => error_unit use random , only : randint use cinter , only : refresh , clear , getch , noecho , cbreak , timeout , printw , kbhit use sleep_std , only : sleep use shapes , only : Piece use fields , only : field use blocks , only : draw_piece implicit none ( type , external ) character ( 14 ) :: buf integer ( c_int ), parameter :: y0 = 5 , L = 10 , W = 80 , H = 60 integer :: Nstates integer ( c_int ) :: ic contains subroutine title ( Fld ) class ( field ), intent ( in ), optional :: Fld type ( field ) :: F integer ( c_int ) :: x , i , ierr type ( piece ) :: T0 , E , T1 , R , A , N if ( present ( fld )) F = Fld call F % setup ( W = W , H = H ) x = 5 T0 = makeLetter ( F , y0 , x , \"t\" ) E = makeLetter ( F , y0 , x + ( L + 1 ), \"e\" ) T1 = makeLetter ( F , y0 , x + 2 * ( L + 1 ), \"t\" ) R = makeLetter ( F , y0 , x + 3 * ( L + 1 ), \"r\" ) A = makeLetter ( F , y0 , x + 4 * ( L + 1 ), \"a\" ) N = makeLetter ( F , y0 , x + 5 * ( L + 1 ), \"n\" ) Nstates = size ( T0 % ch ) call noecho () call cbreak () call timeout ( 0 ) call refresh () call sleep ( 250 ) do i = 1 , Nstates if ( kbhit () /= 0 ) then if ( getch () /= - 1 ) exit endif call clear () if ( F % debug ) then write ( buf , '(A6,I2,A3,I3)' ) 'Loop #' , i , ' / ' , Nstates ierr = printw ( buf ) endif call dissolve ( T0 ) call dissolve ( E ) call dissolve ( T1 ) call dissolve ( R ) call dissolve ( A ) call dissolve ( N ) call refresh () call sleep ( 150 ) enddo end subroutine title type ( piece ) function makeLetter ( F , y0 , x0 , letter ) result ( S ) type ( field ), intent ( in ) :: F integer ( c_int ), intent ( in ) :: y0 , x0 character , intent ( in ) :: letter call S % init ( F , letter , x = x0 , y = y0 ) call draw_piece ( S ) end function makeLetter recursive subroutine dissolve ( P ) class ( piece ), intent ( inout ) :: P integer :: i character ( 10 ) :: buf2 call P % dissolver () !! updates random character for each pixel of this piece do i = 1 , randint ( 0 , P % H / ( L + 1 )) call P % move_down () if ( P % debug ) then if ( P % landed ) then write ( buf2 , '(A6,I2)' ) 'Move #' , i if ( any ( P % screen /= 0 )) error stop 'screen should be == 0' write ( stderr , * ) buf2 // buf // P % btype // ' letter was landed during dissolve ' // P % why endif endif enddo call draw_piece ( P ) end subroutine dissolve end module","tags":"","loc":"sourcefile/menu.f90.html"},{"title":"random.in.f90 – BlockTran","text":"Contents Modules random Source Code random.in.f90 Source Code module random implicit none ( type , external ) interface std procedure std_int , std_real end interface interface mean procedure mean_int , mean_real end interface contains subroutine rand_init ( repeatable , image_distinct ) !! if intrinsic random_init available, use it. logical , intent ( in ) :: repeatable , image_distinct @_ random_init @ end subroutine rand_init impure elemental integer function randint ( lo , hi ) integer , intent ( in ) :: lo , hi real :: r call random_number ( r ) randint = floor ( r * ( hi + 1 - lo )) + lo end function randint !========================================= pure real function std_real ( A ) result ( std ) real , intent ( in ) :: A (:) std = sqrt ( sum ( abs ( A - mean ( A )) ** 2 ) / ( size ( A ) - 1 )) end function std_real pure real function std_int ( A ) result ( std ) integer , intent ( in ) :: A (:) std = sqrt ( sum ( abs ( A - mean ( A )) ** 2 ) / size ( A )) end function std_int !============================================== pure real function mean_real ( A ) result ( mean ) real , intent ( in ) :: A (:) mean = sum ( A ) / size ( A ) end function mean_real pure real function mean_int ( A ) result ( mean ) integer , intent ( in ) :: A (:) mean = sum ( A ) / real ( size ( A )) ! real coerces end function mean_int end module random","tags":"","loc":"sourcefile/random.in.f90.html"},{"title":"rot90.f90 – BlockTran","text":"Contents Modules rotflip Source Code rot90.f90 Source Code module rotflip ! This module provides rot90, flipud, fliplr for Fortran like Matlab and NumPy ! use , intrinsic :: iso_fortran_env , only : stderr => error_unit implicit none ( type , external ) contains integer function rot90 ( A , k ) ! https://github.com/numpy/numpy/blob/v1.14.2/numpy/lib/function_base.py#L54-L138 integer , intent ( in ) :: A (:,:) integer , intent ( in ), optional :: k dimension :: rot90 ( size ( A , 1 ), size ( A , 2 )) integer :: r r = 1 if ( present ( k )) r = k select case ( modulo ( r , 4 )) case ( 0 ) rot90 = A ! unmodified case ( 1 ) rot90 = transpose ( flip ( A , 1 )) case ( 2 ) rot90 = flip ( A , 0 ) case ( 3 ) rot90 = flip ( transpose ( A ), 1 ) end select end function rot90 integer function flip ( A , d ) integer , intent ( in ) :: A (:,:) integer , intent ( in ) :: d integer :: M , N dimension :: flip ( size ( A , 1 ), size ( A , 2 )) M = size ( A , 1 ) N = size ( A , 2 ) select case ( d ) case ( 0 ) ! flip both dimensions flip = A ( M : 1 : - 1 , N : 1 : - 1 ) case ( 1 ) flip = A ( M : 1 : - 1 , :) case ( 2 ) flip = A (:, N : 1 : - 1 ) case default write ( stderr , * ) 'bad flip dimension, 2-D only  (1 or 2), or 0 for both dimensions' end select end function flip integer function flipud ( A ) integer , intent ( in ) :: A (:,:) dimension :: flipud ( size ( A , 1 ), size ( A , 2 )) flipud = flip ( A , 1 ) end function flipud integer function fliplr ( A ) integer , intent ( in ) :: A (:,:) dimension :: fliplr ( size ( A , 1 ), size ( A , 2 )) fliplr = flip ( A , 2 ) end function fliplr end module rotflip","tags":"","loc":"sourcefile/rot90.f90.html"},{"title":"shapes.f90 – BlockTran","text":"Contents Modules shapes Source Code shapes.f90 Source Code module shapes use , intrinsic :: iso_fortran_env , only : stdout => output_unit , stderr => error_unit use rotflip , only : rot90 , fliplr , flipud use fields , only : field use random , only : randint implicit none ( type , external ) private type , extends ( Field ), public :: Piece character :: btype character ( 80 ) :: why character :: ch ( 12 ) integer :: Nx , Ny ! dims of current realization of piece integer :: x , y ! location of piece in playfield integer , allocatable :: values (:,:) ! pixels of piece (third dim is rotation) logical :: landed ! this piece cannot move anymore logical :: movereq ! piece has requested to move in any direction, need to evaluate if collision first. contains procedure , public :: init => init_block , check_collision , move_right , move_left , rotate , move_down , dissolver , & spawn_block , vertflip , horizflip procedure , private :: randomx , tell_why , hit_horiz , hit_floor , hit_block end type public :: gen_type ! for benchmarking contains subroutine init_block ( self , F , btype , x , y ) class ( Piece ), intent ( inout ) :: self class ( field ), intent ( in ) :: F character , intent ( in ), optional :: btype integer , intent ( in ), optional :: x , y integer :: i , j integer , parameter :: Nl = 10 ! Flang / PGI chokes on backslash, so do achar(92). ! also Flang / PGI wants defined length. character , parameter :: ch ( 12 ) = [ \"#\" , \"$\" , \"@\" , \"%\" , \"&\" , \"&#94;\" , \"-\" , \"/\" , \"|\" , achar ( 92 ), \"*\" , \".\" ] ! dynamic generated shapes integer :: line ( 4 , 4 ) = 0 integer :: tee ( 3 , 3 ) = 0 integer :: ell ( 3 , 3 ) = 0 integer :: jay ( 3 , 3 ) = 0 integer :: ess ( 3 , 3 ) = 0 integer :: zee ( 3 , 3 ) = 0 integer :: oh ( 2 , 2 ) = 1 integer :: dot ( 1 , 1 ) = 1 integer :: Lt ( Nl , Nl ) = 0 integer :: Le ( Nl , Nl ) = 0 integer :: Lr ( Nl , Nl ) = 0 integer :: La ( Nl , Nl ) = 0 integer :: Ln ( Nl , Nl ) = 0 !----- line ( 2 ,:) = 1 tee ( 2 ,:) = 1 tee ( 3 , 2 ) = 1 ell ( 2 , 1 : 3 ) = 1 ell ( 3 , 1 ) = 1 jay ( 2 , 1 : 3 ) = 1 jay ( 3 , 3 ) = 1 ess ( 2 , 2 : 3 ) = 1 ess ( 3 , 1 : 2 ) = 1 zee ( 2 , 1 : 2 ) = 1 zee ( 3 , 2 : 3 ) = 1 Lt ( 1 ,:) = 1 Lt (:, Nl / 2 ) = 1 Le ( :: Nl / 2 ,:) = 1 Le ( Nl ,:) = 1 Le (:, 1 ) = 1 Lr ( :: Nl / 2 ,:) = 1 Lr (:, 1 ) = 1 Lr ( 1 : Nl / 2 , Nl ) = 1 j = Nl / 2 do i = Nl / 2 + 1 , Nl j = j + 1 Lr ( i , j ) = 1 enddo La (:, 1 ) = 1 La (:, Nl ) = 1 La (: Nl - 1 : Nl / 2 ,:) = 1 Ln (:, 1 ) = 1 Ln (:, Nl ) = 1 j = 0 do i = 1 , Nl j = j + 1 Ln ( i , j ) = 1 enddo !=============================================================================== if (. not . allocated ( F % screen )) error stop 'must initialize playfield before piece' self % screen = F % screen self % W = size ( self % screen , 2 ) self % H = size ( self % screen , 1 ) self % x0 = F % x0 self % landed = . false . self % movereq = . false . self % y = - 1 if ( present ( y )) self % y = y self % ch = ch if ( present ( btype )) then self % btype = btype else self % btype = gen_type () endif ! Fortran 2003+ allocate-on-assign select case ( self % btype ) case ( \"I\" ) self % values = line case ( \"T\" ) self % values = tee case ( \"L\" ) self % values = ell case ( \"J\" ) self % values = jay case ( \"S\" ) self % values = ess case ( \"Z\" ) self % values = zee case ( \"O\" ) self % values = oh case ( \"D\" ) self % values = dot case ( \"t\" ) self % values = Lt case ( \"e\" ) self % values = Le case ( \"r\" ) self % values = Lr case ( \"a\" ) self % values = La case ( \"n\" ) self % values = Ln case default write ( stderr , * ) 'unknown shape ' // self % btype error stop end select self % Ny = size ( self % values , 1 ) self % Nx = size ( self % values , 2 ) !-------- must come after self%Nx assigned! self % x = self % randomx () if ( present ( x )) self % x = x !-------- if ( self % debug ) then print * , 'shape ' , self % btype , ': Ny,Nx ' , self % Ny , self % Nx endif end subroutine init_block subroutine spawn_block ( self , F , NP ) class ( piece ), intent ( inout ) :: self class ( field ), intent ( inout ) :: F class ( piece ), intent ( inout ), optional :: NP integer :: ib ! make new current piece -- have to do this since \"=\" copys pointers, NOT deep copy for derived types! call self % init ( F , NP % btype ) call NP % init ( F , x = F % W + 5 , y = F % H / 2 ) ! track block count F % Nblock = F % Nblock + 1 ! for game stats ! ----- logging --------- if ( F % Nblock > size ( F % blockseq )) then ib = size ( F % blockseq ) F % blockseq = eoshift ( F % blockseq , 1 ) !OK array-temp else ib = F % Nblock endif F % blockseq ( ib ) = self % btype ! ------ end logging end subroutine spawn_block character function gen_type () result ( next ) ! not elemental because there is no input argument. No need for elemental (could be made so as subroutine) character , parameter :: Btypes ( 8 ) = [ 'I' , 'T' , 'L' , 'J' , 'S' , 'Z' , 'O' , 'D' ] next = Btypes ( randint ( 1 , size ( Btypes ))) end function gen_type subroutine dissolver ( self ) class ( Piece ), intent ( inout ) :: self where ( self % values /= 0 ) self % values = modulo ( self % values + 1 , size ( self % ch ) + 1 ) endwhere end subroutine dissolver subroutine move_left ( self , slam ) class ( Piece ), intent ( inout ) :: self logical , intent ( in ), optional :: slam integer :: i if ( present ( slam )) then if ( slam ) then do i = 1 , self % W self % x = self % x - 1 if ( self % check_collision ()) then self % x = self % x + 1 return endif enddo endif endif !-- one pixel move left attempt self % x = self % x - 1 if ( self % check_collision ()) then self % x = self % x + 1 call self % tell_why () endif end subroutine move_left subroutine move_right ( self , slam ) class ( Piece ), intent ( inout ) :: self logical , intent ( in ), optional :: slam integer :: i if ( present ( slam )) then if ( slam ) then do i = 1 , self % W self % x = self % x + 1 if ( self % check_collision ()) then self % x = self % x - 1 return endif enddo endif endif self % x = self % x + 1 if ( self % check_collision ()) then self % x = self % x - 1 call self % tell_why () endif end subroutine move_right recursive subroutine move_down ( self , slam ) class ( Piece ), intent ( inout ) :: self logical , intent ( in ), optional :: slam if ( self % landed ) then self % why = 'no movement allowed after landing' return endif if ( present ( slam )) then if ( slam ) then do while (. not . self % landed ) call self % move_down () enddo return endif endif ! move down 1 pixel self % y = self % y + 1 if ( self % check_collision ()) then ! landed self % landed = . true . self % y = self % y - 1 call self % tell_why () endif end subroutine move_down subroutine rotate ( self ) class ( Piece ), intent ( inout ) :: self self % values = rot90 ( self % values , 1 ) if ( self % check_collision ()) then call self % tell_why ( 'NO rotation:' ) self % values = rot90 ( self % values , - 1 ) endif end subroutine rotate subroutine vertflip ( self ) class ( Piece ), intent ( inout ) :: self self % values = flipud ( self % values ) if ( self % check_collision ()) then call self % tell_why ( 'NO vertical flip:' ) self % values = flipud ( self % values ) endif end subroutine vertflip subroutine horizflip ( self ) class ( Piece ), intent ( inout ) :: self self % values = fliplr ( self % values ) if ( self % check_collision ()) then call self % tell_why ( 'NO horizontal flip:' ) self % values = fliplr ( self % values ) endif end subroutine horizflip logical function check_collision ( self ) result ( collided ) class ( Piece ), intent ( inout ) :: self ! always check all, in case rotation collided = self % hit_floor () if ( collided ) return collided = self % hit_horiz () if ( collided ) return collided = self % hit_block () end function check_collision logical function hit_floor ( self ) ! NOTE: do NOT set self%alanded in this function, as this will break rotation attempts near floor! class ( Piece ), intent ( inout ) :: self integer :: i hit_floor = . false . do i = 1 , self % Ny if ( all ( self % values ( i ,:) == 0 )) cycle hit_floor = self % y + ( i - 1 ) > self % H if ( hit_floor ) exit enddo if ( hit_floor ) then write ( self % why , '(A20,I3,A3,I3)' ) 'floor hit, y0=' , self % y , 'y=' , self % y + ( i - 1 ) endif end function hit_floor logical function hit_horiz ( self ) class ( Piece ), intent ( inout ) :: self integer :: i hit_horiz = . false . do i = 1 , self % Nx if ( all ( self % values (:, i ) == 0 )) cycle hit_horiz = self % x + ( i - 1 ) < 1 . or . self % x + ( i - 1 ) > self % W if ( hit_horiz ) exit enddo if ( hit_horiz ) write ( self % why , '(A21,I3,A3,I3)' ) 'wall hit, x0=' , self % x , 'x=' , self % x + ( i - 1 ) end function hit_horiz logical function hit_block ( self ) class ( Piece ), intent ( inout ) :: self integer :: i , ix , ixs hit_block = . false . ix = max ( 1 , self % x ) ixs = min ( self % W , ix + self % Nx - ( ix - self % x ) - 1 ) do i = 1 , self % Ny if ( self % y + ( i - 1 ) < 1 ) cycle ! this block row above playfield if ( all ( self % values ( i ,:) == 0 )) cycle ! no part of block in this block row hit_block = any ( self % screen ( self % y + ( i - 1 ), ix : ixs ) + self % values ( i , ix - self % x + 1 : ixs - self % x + 1 ) > & maxval ( self % values ( i , ix - self % x + 1 : ixs - self % x + 1 ))) if ( hit_block ) exit enddo if ( hit_block ) write ( self % why , '(A20,I3,A4,I3)' ) 'block hit, x=' , self % x , ' y=' , self % y end function hit_block integer function randomx ( self ) !! NOTE: even if elemental, because it's part of a class, have to %init() then %randomx() !!    each time, if using externally (which would be unusual) class ( Piece ), intent ( in ) :: self if ( self % W == 0 ) error stop 'playfield has zero width. Be sure to intialize playfield before piece?' if (. not . allocated ( self % values )) error stop 'piece was not allocated' if ( self % Nx < 1 . or . self % Nx >= self % W ) then write ( stderr , '(A,I3,A,I3)' ) 'Nx' , self % Nx , '  W' , self % W error stop 'piece outside playfield @ initial x position' endif randomx = randint ( 1 , self % W - self % Nx ) ! 1 to screen width, minus block width end function randomx subroutine tell_why ( self , msg ) class ( Piece ), intent ( in ) :: self character ( * ), intent ( in ), optional :: msg character (:), allocatable :: str if (. not . self % debug ) return if ( present ( msg )) then str = trim ( msg ) // ' ' // trim ( self % why ) else str = self % why endif write ( stdout , '(A50,A1)' , advance = 'no' ) str , achar ( 13 ) flush ( stdout ) end subroutine tell_why end module shapes","tags":"","loc":"sourcefile/shapes.f90.html"},{"title":"sleep_std.F90 – BlockTran","text":"Contents Modules sleep_std Source Code sleep_std.F90 Source Code module sleep_std use , intrinsic :: iso_c_binding , only : c_int , c_long implicit none ( type , external ) private public :: sleep interface #ifdef _WIN32 subroutine winsleep ( dwMilliseconds ) bind ( C , name = 'Sleep' ) !! void Sleep(DWORD dwMilliseconds) !! https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-sleep import c_long integer ( c_long ), value , intent ( in ) :: dwMilliseconds end subroutine winsleep #else integer ( c_int ) function usleep ( usec ) bind ( C ) !! int usleep(useconds_t usec); !! https://linux.die.net/man/3/usleep import c_int integer ( c_int ), value , intent ( in ) :: usec end function usleep #endif end interface contains subroutine sleep ( millisec ) integer , intent ( in ) :: millisec integer ( c_int ) :: ierr #ifdef _WIN32 !! PGI Windows, Ifort Windows, .... call winsleep ( int ( millisec , c_long )) #else !! Linux, Unix, MacOS, MSYS2, ... ierr = usleep ( int ( millisec * 1000 , c_int )) if ( ierr /= 0 ) error stop 'problem with usleep() system call' #endif end subroutine sleep end module sleep_std","tags":"","loc":"sourcefile/sleep_std.f90.html"},{"title":"unixcinter.f90 – BlockTran","text":"Contents Modules oscinter Source Code unixcinter.f90 Source Code module oscinter use , intrinsic :: iso_c_binding , only : c_int implicit none ( type , external ) contains integer ( c_int ) function kbhit () kbhit = - 1 end function kbhit end module oscinter","tags":"","loc":"sourcefile/unixcinter.f90.html"},{"title":"wincinter.f90 – BlockTran","text":"Contents Modules oscinter Source Code wincinter.f90 Source Code module oscinter use , intrinsic :: iso_c_binding , only : c_int implicit none ( type , external ) interface integer ( c_int ) function kbhit () bind ( c , name = '_kbhit' ) import end function kbhit end interface end module oscinter","tags":"","loc":"sourcefile/wincinter.f90.html"},{"title":"keytest.f90 – BlockTran","text":"Contents Programs keytest Source Code keytest.f90 Source Code program keytest use , intrinsic :: iso_c_binding , only : c_int , c_ptr , c_char , c_bool use cinter , only : initscr , getch , cbreak , timeout , printw , refresh , noecho , kbhit , flushinp , keypad , clear use sleep_std , only : sleep use errs , only : endwin implicit none ( type , external ) type ( c_ptr ) :: stdscr integer ( c_int ) :: ic , ierr character ( kind = c_char , len = 7 ) :: buf logical ( c_bool ), parameter :: true = . true . !, false=.false. stdscr = initscr () call noecho () call cbreak () call timeout ( 0 ) ierr = keypad ( stdscr , true ) if ( ierr /= 0 ) then call endwin () error stop 'problem setting keypad mode' endif ierr = printw ( 'press Esc to exit. Prints keys pressed and their code' // new_line ( '' )) call refresh () do ic = kbhit () if ( ic /= 0 ) then ic = getch () ! 4-byte integer select case ( ic ) case ( - 1 ) !ierr = printw('waiting for getch ') call sleep ( 200 ) cycle case ( 27 ) exit end select else !ierr = printw('waiting for kbhit ') call sleep ( 200 ) !call clear() endif ! read(stdin,*) ic ! Don't do this ! use printw instead. !write(stdout,'(I4,A1,A1)',advance='no') ic,' ',achar(13) !flush(stdout) write ( buf , '(A1,I4,2X)' ) achar ( ic ), ic ierr = printw ( buf ) call refresh () end do call endwin () end program","tags":"","loc":"sourcefile/keytest.f90.html"},{"title":"randtest.f90 – BlockTran","text":"Contents Programs rand_test Source Code randtest.f90 Source Code program rand_test ! confirms random distribution of block types use , intrinsic :: iso_fortran_env , only : dp => real64 use shapes , only : gen_type use random , only : rand_init , randint , std , mean implicit none ( type , external ) character ( * ), parameter :: types = 'ITLJSZOD' integer , parameter :: Ntypes = len ( types ) real , parameter :: rtol = 0.05 real :: ideal character , allocatable :: b (:) real , allocatable :: e (:) integer , allocatable :: f (:), g (:) integer :: i , n , c ( Ntypes ), u character ( 16 ) :: buf call rand_init (. false ., . false .) do i = 1 , 10 print * , randint ( 1 , 8 ) enddo N = 1000000 call get_command_argument ( 1 , buf , status = i ) if ( i == 0 ) read ( buf , * ) N ideal = N / Ntypes allocate ( b ( N ), e ( Ntypes ), f ( N ), g ( N )) do i = 1 , N b ( i ) = gen_type () enddo ! results print '(/,A,I6)' , 'ideal count:' , int ( ideal ) print '(A5,A16,A10)' , 'Block' , 'Count' , 'Error %' print '(A5,A16,A10)' , '-----' , '-----' , '-------' do i = 1 , Ntypes !do concurrent (i=1:Ntypes) ! even with ifort -parallel, still single core (with print commented) c ( i ) = count ( b == types ( i : i )) e ( i ) = abs ( c ( i ) - ideal ) / ideal print '(A5,I16,F10.3)' , types ( i : i ), c ( i ), e ( i ) * 100 enddo ! randomness simple check -- sufficiently uniformly random if ( any ( e > rtol )) then error stop 'non-uniform randomness posssible. Is N > 1000000?' endif ! ----------- do i = 1 , N f ( i ) = randint ( - 1073741823 , 1073741823 ) enddo print '(/,A,I15,A,F15.3)' , 'huge(int)' , huge ( 0 ), 'huge(real)' , huge ( 0. ) print * , 'expected std, mean' , real ( huge ( 0 ), dp ) / sqrt ( 1 2._dp ), 0. print * , 'std, mean randint()' , std ( f ), mean ( f ) print * , 'a few values' , f (: 6 ) open ( newunit = u , file = '/dev/urandom' , access = \"stream\" , form = \"unformatted\" , action = \"read\" , status = \"old\" , iostat = i ) if ( i == 0 ) then read ( u ) g close ( u ) print '(/,A)' , '/dev/urandom a few values...' print * , 'std, mean /dev/urandom' , std ( g ), mean ( g ) endif end program","tags":"","loc":"sourcefile/randtest.f90.html"},{"title":"test_curses.f90 – BlockTran","text":"Contents Programs test_curses Source Code test_curses.f90 Source Code program test_curses ! Test Fortran CURSES interface use , intrinsic :: iso_c_binding , only : c_ptr , c_int use cinter , only : initscr , endwin , mvprintw , printw , refresh , LINES , COLS use sleep_std , only : sleep implicit none ( type , external ) integer ( c_int ) :: ierr type ( c_ptr ) :: stdscr stdscr = initscr () ierr = printw ( 'hi from Curses' ) call refresh () call sleep ( 1000 ) call endwin () print * , 'terminal window detected size: lines' , lines , 'cols' , cols end program","tags":"","loc":"sourcefile/test_curses.f90.html"},{"title":"test_menu.f90 – BlockTran","text":"Contents Programs test_menu Source Code test_menu.f90 Source Code program test_menu use , intrinsic :: iso_c_binding , only : c_ptr , c_int use cinter , only : initscr , endwin , nodelay use menu , only : title implicit none ( type , external ) type ( c_ptr ) :: stdscr stdscr = initscr () call title () call endwin () end program","tags":"","loc":"sourcefile/test_menu.f90.html"},{"title":"test_motion.f90 – BlockTran","text":"Contents Programs test_motion Source Code test_motion.f90 Source Code program test_motion ! -------- shape horiz. movement & rotation ! FIXME: Each shape should be tested. use , intrinsic :: iso_fortran_env , only : stderr => error_unit use shapes , only : piece use fields , only : field implicit none ( type , external ) integer , parameter :: W = 10 , H = 10 if ( initial ( \"I\" )) error stop 'initial' if ( test_floor ( \"I\" )) error stop 'floor' if ( left_wall ( \"I\" )) error stop 'left' if ( right_wall ( \"I\" )) error stop 'right' if ( block_hit ( \"I\" )) error stop 'block' print * , 'OK motion' contains logical function initial ( next ) result ( failed ) character , intent ( in ) :: next type ( field ) :: F type ( piece ) :: P failed = . true . print * , 'intiial position test...' call F % setup ( W = W , H = H ) call P % init ( F , btype = next , x = W / 2 ) if (. not .( P % y ==- 1 )) then write ( stderr , * ) next // ' bad initial Y position' return endif if ( P % landed ) then write ( stderr , * ) next // ' was initially landed' return endif call print_piece ( P ) failed = . false . end function initial logical function test_floor ( next ) result ( failed ) character , intent ( in ) :: next type ( field ) :: F type ( piece ) :: P integer :: y ! test positions failed = . true . print * , 'floor hit test...' call F % setup ( W = W , H = H ) call P % init ( F , next , W / 2 ) call P % move_down () ! y=0 y = P % y call P % move_down () ! y=1 if (. not .( y == P % y - 1 ) . and . P % y == 1 ) then write ( stderr , * ) next // ' failed to move down' , P % why return endif call P % move_down () ! y=2 call P % move_down () ! y=3 call P % move_down () ! y=4 call P % move_down () ! y=5 call P % move_down () ! y=6 call P % move_down () ! y=7 call P % move_down () ! y=8 call P % move_down () ! y=9 at bottom (allow sliding along floor before final freeze) if ( P % landed ) then write ( stderr , * ) next // ' floor before rotation) failing to slide along floor' , P % why return endif call P % move_down () ! y=10-1 landed (frozen) on bottom if (. not . P % landed ) then write ( stderr , * ) next // ' (floor before rotation)  failed to land.  Y=' , P % y return endif print * , 'OK:  ' , P % why y = P % y call P % move_down () ! y=10-1 frozen if (. not .( y == P % y )) then write ( stderr , * ) next // ' passed through floor!' , P % why return endif print * , 'OK:  ' , P % why y = P % y P % y = P % y - 1 ; P % landed = . false . ! y=9 manually unfreeze call P % rotate () if ( P % landed ) then write ( stderr , * ) next // ' (after rotation) early landing' , P % why return endif !call print_piece(P) call P % move_down () ! y=6 if ( P % landed ) then ! print *,'x,y', P%x, P%y write ( stderr , * ) next // ' (after rotation and movedown) failing to slide along floor' , P % why return endif call P % move_down () ! y=7 landed (frozen) on bottom if (. not . P % landed ) then write ( stderr , * ) next // ' (after rotation) failed to land' , P % why return endif y = P % y call P % move_down () ! y=7 pressing on bottom if (. not .( y == P % y )) then write ( stderr , * ) next // ' passed through floor!' , P % why return endif y = P % y failed = . false . end function test_floor logical function left_wall ( next ) result ( failed ) character , intent ( in ) :: next type ( field ) :: F type ( piece ) :: P integer :: x ! test positions failed = . true . print * , 'left wall test...' ! -- Left wall call F % setup ( W , H ) call P % init ( F , btype = next , x = W / 2 ) x = P % x call P % move_left () ! x=4 if ( P % x /= x - 1 ) then write ( stderr , * ) next // ' failed to move left' , P % why return endif call P % move_left () ! x=3 call P % move_left () ! x=2 call P % move_left () ! x=1 at left wall if ( P % x /= 1 ) then write ( stderr , * ) next // ' passing through left wall!' , P % why return endif x = P % x !call print_piece(line) ! -- rotate left wall call P % rotate () !call print_piece(line) call P % move_left () ! x=0 at left wall if ( P % x /= 0 ) then write ( stderr , * ) next // ' I move left after rotate' , P % why return endif call P % move_left () ! at left wall call P % move_left () ! pushing on left wall if ( P % x /= - 1 ) then write ( stderr , * ) next // ' I move left collision detection' , P % why return endif failed = . false . end function left_wall logical function right_wall ( next ) result ( failed ) character , intent ( in ) :: next type ( field ) :: F type ( piece ) :: P integer :: x ! test positions failed = . true . print * , 'right wall test...' call F % setup ( W , H ) call P % init ( F , next , W / 2 ) x = P % x !call print_piece(line) call P % move_right () ! x=5 if ( P % x /= x + 1 ) then write ( stderr , * ) next // ' failed to move right' , P % why return endif call P % move_right () ! x=6 call P % move_right () ! x=6 call P % move_right () ! x=7 at right wall call P % move_right () ! x=7 pushing on right wall if ( P % x /= W - 3 ) then write ( stderr , * ) next // ' (before rotate) I move right collision detection' , P % why return endif call P % rotate () call P % move_right () ! at right wall call P % move_right () ! pushing on right wall if ( P % x /= W - 2 ) then write ( stderr , * ) next // ' (after rotate) I move right collision detection' , P % why return endif failed = . false . end function right_wall logical function block_hit ( next ) result ( failed ) character , intent ( in ) :: next type ( field ) :: F type ( piece ) :: P integer :: y ! test positions failed = . true . print * , 'block hit test...' call F % setup ( W , H ) !-- single pixel object in center bottom of floor F % screen ( H - 2 , W / 2 ) = 1 !call print_block(F%screen) call P % init ( F , btype = next , x = W / 2 ) call P % rotate () !call print_piece(P) call P % move_down () ! y=0 y = P % y call P % move_down () ! y=1 if (. not .( y == P % y - 1 ) . and . P % y == 1 ) then write ( stderr , * ) next // ' (obj) failure to move down' , P % why return endif call P % move_down () ! y=2 call P % move_down () ! y=3 call P % move_down () ! y=4 call P % move_down () ! y=5 next to bottom (allow sliding along floor before final freeze) if ( P % landed ) then write ( stderr , * ) 'x,y' , P % x , P % y write ( stderr , * ) next // ' (obj before rotation) failing to slide along object' , P % why return endif call P % move_down () ! y=5 landed (frozen) on bottom call P % move_down () ! y=5 landed (frozen) on bottom call P % move_down () ! y=5 landed (frozen) on bottom if (. not . P % landed ) then write ( stderr , * ) next // ' (obj before rotation)  failed to land' , P % why return endif y = P % y call P % move_down () ! y=5 pressing on bottom if (. not .( y == P % y )) then write ( stderr , * ) next // ' obj passed through floor!' , P % why return endif y = P % y failed = . false . end function block_hit subroutine print_piece ( P ) class ( piece ), intent ( in ) :: P call print_block ( P % values ) end subroutine print_piece subroutine print_block ( B ) integer , intent ( in ) :: B (:,:) integer :: i do i = 1 , size ( B , 1 ) print '(8I1)' , B ( i ,:) enddo end subroutine print_block end program","tags":"","loc":"sourcefile/test_motion.f90.html"},{"title":"test_shapes.f90 – BlockTran","text":"Contents Programs test_shapes Source Code test_shapes.f90 Source Code program test_shapes use , intrinsic :: iso_fortran_env , only : stderr => error_unit use shapes , only : piece use fields , only : field use random , only : rand_init implicit none ( type , external ) type ( field ) :: F type ( piece ) :: S , line , tee , ell , jay , ess , zee , oh integer , parameter :: Ny = 4 , Nx = 4 , W = 6 , H = 10 integer , parameter :: Ntest = 100 ! arbitrary integer :: i integer :: xarr ( Ntest ) ! test for randomness etc. call rand_init (. false ., . false .) call F % setup ( W = W , H = H ) ! must generate playfield before any pieces, or they will die when they realize they're outside a playfield !print '(6I1)',transpose(F%screen) print * , 'H ' , F % H , 'W ' , F % W !------- shape essentials print * , 'initial x-position test....' do i = 1 , Ntest call S % init ( F , \"I\" ) xarr ( i ) = S % x enddo call check_x ( xarr ) print * , 'random shape types test...' if ( all ( xarr == xarr ( 1 ))) error stop 'non-random shape initial x-position' print * , 'initial y position test...' if (. not . S % y ==- 1 ) then write ( stderr , '(A,I3)' ) 'initial y position ' , S % y error stop 'shape initial y-position not at top of playfield (-1)' endif print * , 'test I' call line % init ( F , \"I\" ) if (. not . line % btype == 'I' ) error stop 'I type' if (. not . allocated ( line % values )) error stop 'I init' if (. not . all ( shape ( line % values ) == [ Ny , Nx ])) error stop 'I shape' print * , 'test T' call tee % init ( F , \"T\" ) if (. not . tee % btype == 'T' ) error stop 'T type' if (. not . allocated ( tee % values )) error stop 'T init' if (. not . all ( shape ( tee % values ) == [ Ny - 1 , Nx - 1 ])) error stop 'T shape' print * , 'test L' call ell % init ( F , \"L\" ) if (. not . ell % btype == 'L' ) error stop 'L type' if (. not . allocated ( ell % values )) error stop 'L init' if (. not . all ( shape ( ell % values ) == [ Ny - 1 , Nx - 1 ])) error stop 'L shape' print * , 'test J' call jay % init ( F , \"J\" ) if (. not . jay % btype == 'J' ) error stop 'J type' if (. not . allocated ( jay % values )) error stop 'J init' if (. not . all ( shape ( jay % values ) == [ Ny - 1 , Nx - 1 ])) error stop 'J shape' print * , 'test S' call ess % init ( F , \"S\" ) if (. not . ess % btype == 'S' ) error stop 'S type' if (. not . allocated ( ess % values )) error stop 'S init' if (. not . all ( shape ( ess % values ) == [ Ny - 1 , Nx - 1 ])) error stop 'S shape' print * , 'test Z' call zee % init ( F , \"Z\" ) if (. not . zee % btype == 'Z' ) error stop 'Z type' if (. not . allocated ( zee % values )) error stop 'Z init' if (. not . all ( shape ( zee % values ) == [ Ny - 1 , Nx - 1 ])) error stop 'Z shape' print * , 'test O' call oh % init ( F , \"O\" ) if (. not . oh % btype == 'O' ) error stop 'O type' if (. not . allocated ( oh % values )) error stop 'O init' if (. not . all ( shape ( oh % values ) == [ Ny - 2 , Nx - 2 ])) error stop 'O shape' print * , 'OK shapes' contains subroutine check_x ( x ) integer , intent ( in ) :: x (:) if (. not .( minval ( x ) >= 1 . and . maxval ( x ) <= W - Nx )) then write ( stderr , '(A,I3,A,I3)' ) 'min(x) ' , minval ( x ), ' max(x) ' , maxval ( x ) error stop 'shape initial X position out of playfield' endif if ( all ( x == x ( 1 ))) then write ( stderr , '(A,I1)' ) 'all X are identically ' , x ( 1 ) error stop 'non random x' endif end subroutine check_x end program","tags":"","loc":"sourcefile/test_shapes.f90.html"},{"title":"Field – BlockTran ","text":"type, public :: Field Contents Variables move_time sleep_incr difffact level diffinc score Nblock Ncleared lines_per_level bonus blockseq toc tic H W x0 screen debug udbg newhit cheat AI Type-Bound Procedures clear_lines levelup setup Components Type Visibility Attributes Name Initial real, public :: move_time = 0.5 integer(kind=c_int), public :: sleep_incr = 50 real, public :: difffact = 1. integer, public :: level = 1 real, public :: diffinc = 1.2 integer, public :: score = 0 integer, public :: Nblock = 0 integer, public :: Ncleared = 0 integer, public :: lines_per_level = 10 integer, public :: bonus (-1:4) = [-100, 0, 40, 100, 300, 1200] character(len=1), public :: blockseq (10000) = \"\" integer, public :: toc integer, public :: tic integer, public :: H integer, public :: W integer, public :: x0 integer, public, allocatable :: screen (:,:) logical, public :: debug = .false. integer, public :: udbg logical, public :: newhit = .false. logical, public :: cheat = .false. logical, public :: AI Type-Bound Procedures procedure, public :: clear_lines private subroutine clear_lines (self) Arguments Type Intent Optional Attributes Name class( Field ), intent(inout) :: self procedure, public :: levelup private subroutine levelup (self) Arguments Type Intent Optional Attributes Name class( Field ), intent(inout) :: self procedure, public :: setup private subroutine setup (self, W, H, x0, AI, difffact, debug) Arguments Type Intent Optional Attributes Name class( Field ), intent(inout) :: self integer, intent(in) :: W integer, intent(in) :: H integer, intent(in), optional :: x0 logical, intent(in), optional :: AI real, intent(in), optional :: difffact logical, intent(in), optional :: debug","tags":"","loc":"type/field.html"},{"title":"Piece – BlockTran ","text":"type, public, extends( Field ) :: Piece Contents Variables move_time sleep_incr difffact level diffinc score Nblock Ncleared lines_per_level bonus blockseq toc tic H W x0 screen debug udbg newhit cheat AI btype why ch Nx Ny x y values landed movereq Type-Bound Procedures clear_lines levelup setup horizflip vertflip spawn_block dissolver move_down rotate move_left move_right check_collision init hit_block hit_floor hit_horiz tell_why randomx Components Type Visibility Attributes Name Initial real, public :: move_time = 0.5 integer(kind=c_int), public :: sleep_incr = 50 real, public :: difffact = 1. integer, public :: level = 1 real, public :: diffinc = 1.2 integer, public :: score = 0 integer, public :: Nblock = 0 integer, public :: Ncleared = 0 integer, public :: lines_per_level = 10 integer, public :: bonus (-1:4) = [-100, 0, 40, 100, 300, 1200] character(len=1), public :: blockseq (10000) = \"\" integer, public :: toc integer, public :: tic integer, public :: H integer, public :: W integer, public :: x0 integer, public, allocatable :: screen (:,:) logical, public :: debug = .false. integer, public :: udbg logical, public :: newhit = .false. logical, public :: cheat = .false. logical, public :: AI character, public :: btype character(len=80), public :: why character, public :: ch (12) integer, public :: Nx integer, public :: Ny integer, public :: x integer, public :: y integer, public, allocatable :: values (:,:) logical, public :: landed logical, public :: movereq Type-Bound Procedures procedure, public :: clear_lines private subroutine clear_lines (self) Arguments Type Intent Optional Attributes Name class( Field ), intent(inout) :: self procedure, public :: levelup private subroutine levelup (self) Arguments Type Intent Optional Attributes Name class( Field ), intent(inout) :: self procedure, public :: setup private subroutine setup (self, W, H, x0, AI, difffact, debug) Arguments Type Intent Optional Attributes Name class( Field ), intent(inout) :: self integer, intent(in) :: W integer, intent(in) :: H integer, intent(in), optional :: x0 logical, intent(in), optional :: AI real, intent(in), optional :: difffact logical, intent(in), optional :: debug procedure, public :: horizflip private subroutine horizflip (self) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self procedure, public :: vertflip private subroutine vertflip (self) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self procedure, public :: spawn_block private subroutine spawn_block (self, F, NP) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self class( Field ), intent(inout) :: F class( Piece ), intent(inout), optional :: NP procedure, public :: dissolver private subroutine dissolver (self) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self procedure, public :: move_down private recursive subroutine move_down (self, slam) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self logical, intent(in), optional :: slam procedure, public :: rotate private subroutine rotate (self) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self procedure, public :: move_left private subroutine move_left (self, slam) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self logical, intent(in), optional :: slam procedure, public :: move_right private subroutine move_right (self, slam) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self logical, intent(in), optional :: slam procedure, public :: check_collision private function check_collision (self) result(collided) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self Return Value logical procedure, public :: init => init_block private subroutine init_block (self, F, btype, x, y) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self class( Field ), intent(in) :: F character, intent(in), optional :: btype integer, intent(in), optional :: x integer, intent(in), optional :: y procedure, private :: hit_block private function hit_block (self) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self Return Value logical procedure, private :: hit_floor private function hit_floor (self) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self Return Value logical procedure, private :: hit_horiz private function hit_horiz (self) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self Return Value logical procedure, private :: tell_why private subroutine tell_why (self, msg) Arguments Type Intent Optional Attributes Name class( Piece ), intent(in) :: self character(len=*), intent(in), optional :: msg procedure, private :: randomx private function randomx (self) Arguments Type Intent Optional Attributes Name class( Piece ), intent(in) :: self Return Value integer","tags":"","loc":"type/piece.html"},{"title":"addone – BlockTran","text":"interface function addone(N) bind(C) Arguments Type Intent Optional Attributes Name integer, intent(in), value :: N Return Value integer","tags":"","loc":"interface/addone.html"},{"title":"project_down – BlockTran","text":"public function project_down(F, P) result(y) Arguments Type Intent Optional Attributes Name class( Field ), intent(in) :: F class( Piece ), intent(in) :: P Return Value integer Contents None","tags":"","loc":"proc/project_down.html"},{"title":"height – BlockTran","text":"public function height(F, P) Arguments Type Intent Optional Attributes Name class( Field ), intent(in) :: F class( Piece ), intent(in) :: P Return Value integer Contents None","tags":"","loc":"proc/height.html"},{"title":"diff – BlockTran","text":"public pure function diff(A) Arguments Type Intent Optional Attributes Name integer, intent(in) :: A (:) Return Value integer Contents None","tags":"","loc":"proc/diff.html"},{"title":"AI_input – BlockTran","text":"public subroutine AI_input(F, P) Arguments Type Intent Optional Attributes Name class( Field ), intent(in) :: F class( Piece ), intent(inout) :: P Contents None","tags":"","loc":"proc/ai_input.html"},{"title":"seek_deep – BlockTran","text":"public subroutine seek_deep(F, P) Arguments Type Intent Optional Attributes Name class( Field ), intent(in) :: F class( Piece ), intent(inout) :: P Contents None","tags":"","loc":"proc/seek_deep.html"},{"title":"down_random – BlockTran","text":"public subroutine down_random(P) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: P Contents None","tags":"","loc":"proc/down_random.html"},{"title":"move_random – BlockTran","text":"public subroutine move_random(P) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: P Contents None","tags":"","loc":"proc/move_random.html"},{"title":"draw_piece – BlockTran","text":"public subroutine draw_piece(P) Arguments Type Intent Optional Attributes Name class( Piece ), intent(in) :: P Contents None","tags":"","loc":"proc/draw_piece.html"},{"title":"freeze – BlockTran","text":"public subroutine freeze(F, P, NP) Arguments Type Intent Optional Attributes Name class( Field ), intent(inout) :: F class( Piece ), intent(inout) :: P class( Piece ), intent(inout) :: NP Contents None","tags":"","loc":"proc/freeze.html"},{"title":"game_over – BlockTran","text":"public subroutine game_over(F, P, msg) Arguments Type Intent Optional Attributes Name class( Field ), intent(in) :: F class( Piece ), intent(in), optional :: P character(len=*), intent(in), optional :: msg Contents None","tags":"","loc":"proc/game_over.html"},{"title":"initscr – BlockTran","text":"public function initscr() result(stdscr__OUT) Arguments None Return Value type(C_PTR) Contents None","tags":"","loc":"proc/initscr.html"},{"title":"addch – BlockTran","text":"public subroutine addch(ch) Arguments Type Intent Optional Attributes Name character(kind=c_char), intent(in), value :: ch Contents None","tags":"","loc":"proc/addch.html"},{"title":"f_initscr – BlockTran","text":"interface public function f_initscr() result(initscr__OUT) bind(C, name='initscr') Arguments None Return Value type(c_ptr)","tags":"","loc":"interface/f_initscr.html"},{"title":"getch – BlockTran","text":"interface public function getch() result(ch) bind(C) Arguments None Return Value integer(kind=c_int)","tags":"","loc":"interface/getch.html"},{"title":"nodelay – BlockTran","text":"interface public function nodelay(win, bf) result(ierr) bind(C, name='nodelay') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: win logical(kind=C_BOOL), value :: bf Return Value integer(kind=C_INT) Description http://www.urbanjost.altervista.org/LIBRARY/libscreen/ncurses/pdsrc/ncurses.f90","tags":"","loc":"interface/nodelay.html"},{"title":"keypad – BlockTran","text":"interface public function keypad(win, bf) result(ierr) bind(C, name='keypad') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: win logical(kind=C_BOOL), value :: bf Return Value integer(kind=C_INT) Description http://www.urbanjost.altervista.org/LIBRARY/libscreen/ncurses/pdsrc/ncurses.f90","tags":"","loc":"interface/keypad.html"},{"title":"f_addch – BlockTran","text":"interface public function f_addch(ch) result(addch__OUT) bind(c, name='addch') Arguments Type Intent Optional Attributes Name character(kind=c_char), intent(in), value :: ch Return Value integer(kind=c_int)","tags":"","loc":"interface/f_addch.html"},{"title":"printw – BlockTran","text":"interface public function printw(str) bind(C) Arguments Type Intent Optional Attributes Name character(kind=c_char), intent(in) :: str Return Value integer(kind=c_int)","tags":"","loc":"interface/printw.html"},{"title":"getmaxyx – BlockTran","text":"interface public subroutine getmaxyx(win, y, x) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: win integer(kind=c_int) :: y integer(kind=c_int) :: x","tags":"","loc":"interface/getmaxyx.html"},{"title":"endwin – BlockTran","text":"interface public subroutine endwin() bind(C) Arguments None","tags":"","loc":"interface/endwin.html"},{"title":"flushinp – BlockTran","text":"interface public subroutine flushinp() bind(c) Arguments None","tags":"","loc":"interface/flushinp.html"},{"title":"timeout – BlockTran","text":"interface public subroutine timeout(delay) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: delay Description timeout(0) => non-blocking getch() (-1 if no keypress)","tags":"","loc":"interface/timeout.html"},{"title":"mvaddch – BlockTran","text":"interface public subroutine mvaddch(y, x, ch) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: y integer(kind=c_int), intent(in), value :: x character(kind=c_char), intent(in), value :: ch","tags":"","loc":"interface/mvaddch.html"},{"title":"refresh – BlockTran","text":"interface public subroutine refresh() bind(C) Arguments None","tags":"","loc":"interface/refresh.html"},{"title":"clear – BlockTran","text":"interface public subroutine clear() bind(C) Arguments None Description clear entire screen","tags":"","loc":"interface/clear.html"},{"title":"border – BlockTran","text":"interface public subroutine border() bind(C) Arguments None Description draw border","tags":"","loc":"interface/border.html"},{"title":"noecho – BlockTran","text":"interface public subroutine noecho() bind(C) Arguments None","tags":"","loc":"interface/noecho.html"},{"title":"cbreak – BlockTran","text":"interface public subroutine cbreak() bind(C) Arguments None","tags":"","loc":"interface/cbreak.html"},{"title":"mvprintw – BlockTran","text":"interface public subroutine mvprintw(y, x, str) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: y integer(kind=c_int), intent(in), value :: x character(kind=c_char), intent(in) :: str","tags":"","loc":"interface/mvprintw.html"},{"title":"err – BlockTran","text":"public subroutine err(msg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: msg Contents None","tags":"","loc":"proc/err.html"},{"title":"setup – BlockTran","text":"private subroutine setup(self, W, H, x0, AI, difffact, debug) Arguments Type Intent Optional Attributes Name class( Field ), intent(inout) :: self integer, intent(in) :: W integer, intent(in) :: H integer, intent(in), optional :: x0 logical, intent(in), optional :: AI real, intent(in), optional :: difffact logical, intent(in), optional :: debug Contents None","tags":"","loc":"proc/setup.html"},{"title":"levelup – BlockTran","text":"private subroutine levelup(self) Arguments Type Intent Optional Attributes Name class( Field ), intent(inout) :: self Contents None","tags":"","loc":"proc/levelup.html"},{"title":"clear_lines – BlockTran","text":"private subroutine clear_lines(self) Arguments Type Intent Optional Attributes Name class( Field ), intent(inout) :: self Contents None","tags":"","loc":"proc/clear_lines.html"},{"title":"main_game – BlockTran","text":"public subroutine main_game(W, H) get tick rae initialize Curses Arguments Type Intent Optional Attributes Name integer, intent(in) :: W integer, intent(in) :: H Contents None","tags":"","loc":"proc/main_game.html"},{"title":"mainsub – BlockTran","text":"public subroutine mainsub(F, P, NP) time's up, move piece one step down. real(trate) is necessary for float time comparison! Arguments Type Intent Optional Attributes Name class( Field ) :: F type( Piece ) :: P type( Piece ) :: NP Contents None","tags":"","loc":"proc/mainsub.html"},{"title":"redraw – BlockTran","text":"public subroutine redraw(F, P, NP) Arguments Type Intent Optional Attributes Name class( Field ), intent(in) :: F class( Piece ), intent(in) :: P class( Piece ), intent(in) :: NP Contents None","tags":"","loc":"proc/redraw.html"},{"title":"cmd_parse – BlockTran","text":"public subroutine cmd_parse(W, H) Arguments Type Intent Optional Attributes Name integer, intent(out) :: W integer, intent(out) :: H Contents None","tags":"","loc":"proc/cmd_parse.html"},{"title":"draw_screen – BlockTran","text":"public subroutine draw_screen(F) Arguments Type Intent Optional Attributes Name class( Field ), intent(in) :: F Contents None","tags":"","loc":"proc/draw_screen.html"},{"title":"draw_score – BlockTran","text":"public subroutine draw_score(F) Arguments Type Intent Optional Attributes Name class( Field ), intent(in) :: F Contents None","tags":"","loc":"proc/draw_score.html"},{"title":"key_input – BlockTran","text":"public subroutine key_input(F, P, NP) Arguments Type Intent Optional Attributes Name class( Field ), intent(inout) :: F class( Piece ), intent(inout) :: P class( Piece ), intent(inout), optional :: NP Contents None","tags":"","loc":"proc/key_input.html"},{"title":"makeLetter – BlockTran","text":"public function makeLetter(F, y0, x0, letter) result(S) Arguments Type Intent Optional Attributes Name type( Field ), intent(in) :: F integer(kind=c_int), intent(in) :: y0 integer(kind=c_int), intent(in) :: x0 character, intent(in) :: letter Return Value type( Piece ) Contents None","tags":"","loc":"proc/makeletter.html"},{"title":"title – BlockTran","text":"public subroutine title(Fld) Arguments Type Intent Optional Attributes Name class( Field ), intent(in), optional :: Fld Contents None","tags":"","loc":"proc/title.html"},{"title":"dissolve – BlockTran","text":"public recursive subroutine dissolve(P) updates random character for each pixel of this piece Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: P Contents None","tags":"","loc":"proc/dissolve.html"},{"title":"randint – BlockTran","text":"public impure elemental function randint(lo, hi) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lo integer, intent(in) :: hi Return Value integer Contents None","tags":"","loc":"proc/randint.html"},{"title":"std_real – BlockTran","text":"public pure function std_real(A) result(std) Arguments Type Intent Optional Attributes Name real, intent(in) :: A (:) Return Value real Contents None","tags":"","loc":"proc/std_real.html"},{"title":"std_int – BlockTran","text":"public pure function std_int(A) result(std) Arguments Type Intent Optional Attributes Name integer, intent(in) :: A (:) Return Value real Contents None","tags":"","loc":"proc/std_int.html"},{"title":"mean_real – BlockTran","text":"public pure function mean_real(A) result(mean) Arguments Type Intent Optional Attributes Name real, intent(in) :: A (:) Return Value real Contents None","tags":"","loc":"proc/mean_real.html"},{"title":"mean_int – BlockTran","text":"public pure function mean_int(A) result(mean) Arguments Type Intent Optional Attributes Name integer, intent(in) :: A (:) Return Value real Contents None","tags":"","loc":"proc/mean_int.html"},{"title":"rand_init – BlockTran","text":"public subroutine rand_init(repeatable, image_distinct) if intrinsic random_init available, use it. Arguments Type Intent Optional Attributes Name logical, intent(in) :: repeatable logical, intent(in) :: image_distinct Contents None","tags":"","loc":"proc/rand_init.html"},{"title":"std – BlockTran","text":"public interface std Contents Module Procedures std_int std_real Module Procedures public pure function std_int (A) result(std) Arguments Type Intent Optional Attributes Name integer, intent(in) :: A (:) Return Value real public pure function std_real (A) result(std) Arguments Type Intent Optional Attributes Name real, intent(in) :: A (:) Return Value real","tags":"","loc":"interface/std.html"},{"title":"mean – BlockTran","text":"public interface mean Contents Module Procedures mean_int mean_real Module Procedures public pure function mean_int (A) result(mean) Arguments Type Intent Optional Attributes Name integer, intent(in) :: A (:) Return Value real public pure function mean_real (A) result(mean) Arguments Type Intent Optional Attributes Name real, intent(in) :: A (:) Return Value real","tags":"","loc":"interface/mean.html"},{"title":"rot90 – BlockTran","text":"public function rot90(A, k) Arguments Type Intent Optional Attributes Name integer, intent(in) :: A (:,:) integer, intent(in), optional :: k Return Value integer Contents None","tags":"","loc":"proc/rot90.html"},{"title":"flip – BlockTran","text":"public function flip(A, d) Arguments Type Intent Optional Attributes Name integer, intent(in) :: A (:,:) integer, intent(in) :: d Return Value integer Contents None","tags":"","loc":"proc/flip.html"},{"title":"flipud – BlockTran","text":"public function flipud(A) Arguments Type Intent Optional Attributes Name integer, intent(in) :: A (:,:) Return Value integer Contents None","tags":"","loc":"proc/flipud.html"},{"title":"fliplr – BlockTran","text":"public function fliplr(A) Arguments Type Intent Optional Attributes Name integer, intent(in) :: A (:,:) Return Value integer Contents None","tags":"","loc":"proc/fliplr.html"},{"title":"gen_type – BlockTran","text":"public function gen_type() result(next) Arguments None Return Value character Contents None","tags":"","loc":"proc/gen_type.html"},{"title":"check_collision – BlockTran","text":"private function check_collision(self) result(collided) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self Return Value logical Contents None","tags":"","loc":"proc/check_collision.html"},{"title":"hit_floor – BlockTran","text":"private function hit_floor(self) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self Return Value logical Contents None","tags":"","loc":"proc/hit_floor.html"},{"title":"hit_horiz – BlockTran","text":"private function hit_horiz(self) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self Return Value logical Contents None","tags":"","loc":"proc/hit_horiz.html"},{"title":"hit_block – BlockTran","text":"private function hit_block(self) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self Return Value logical Contents None","tags":"","loc":"proc/hit_block.html"},{"title":"randomx – BlockTran","text":"private function randomx(self) Arguments Type Intent Optional Attributes Name class( Piece ), intent(in) :: self Return Value integer Contents None","tags":"","loc":"proc/randomx.html"},{"title":"init_block – BlockTran","text":"private subroutine init_block(self, F, btype, x, y) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self class( Field ), intent(in) :: F character, intent(in), optional :: btype integer, intent(in), optional :: x integer, intent(in), optional :: y Contents None","tags":"","loc":"proc/init_block.html"},{"title":"spawn_block – BlockTran","text":"private subroutine spawn_block(self, F, NP) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self class( Field ), intent(inout) :: F class( Piece ), intent(inout), optional :: NP Contents None","tags":"","loc":"proc/spawn_block.html"},{"title":"dissolver – BlockTran","text":"private subroutine dissolver(self) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self Contents None","tags":"","loc":"proc/dissolver.html"},{"title":"move_left – BlockTran","text":"private subroutine move_left(self, slam) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self logical, intent(in), optional :: slam Contents None","tags":"","loc":"proc/move_left.html"},{"title":"move_right – BlockTran","text":"private subroutine move_right(self, slam) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self logical, intent(in), optional :: slam Contents None","tags":"","loc":"proc/move_right.html"},{"title":"move_down – BlockTran","text":"private recursive subroutine move_down(self, slam) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self logical, intent(in), optional :: slam Contents None","tags":"","loc":"proc/move_down.html"},{"title":"rotate – BlockTran","text":"private subroutine rotate(self) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self Contents None","tags":"","loc":"proc/rotate.html"},{"title":"vertflip – BlockTran","text":"private subroutine vertflip(self) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self Contents None","tags":"","loc":"proc/vertflip.html"},{"title":"horizflip – BlockTran","text":"private subroutine horizflip(self) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self Contents None","tags":"","loc":"proc/horizflip.html"},{"title":"tell_why – BlockTran","text":"private subroutine tell_why(self, msg) Arguments Type Intent Optional Attributes Name class( Piece ), intent(in) :: self character(len=*), intent(in), optional :: msg Contents None","tags":"","loc":"proc/tell_why.html"},{"title":"sleep – BlockTran","text":"public subroutine sleep(millisec) Arguments Type Intent Optional Attributes Name integer, intent(in) :: millisec Contents None","tags":"","loc":"proc/sleep.html"},{"title":"winsleep – BlockTran","text":"interface private subroutine winsleep(dwMilliseconds) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer(kind=c_long), intent(in), value :: dwMilliseconds Description void Sleep(DWORD dwMilliseconds)\n https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-sleep","tags":"","loc":"interface/winsleep.html"},{"title":"kbhit – BlockTran","text":"public function kbhit() Arguments None Return Value integer(kind=c_int) Contents None","tags":"","loc":"proc/kbhit.html"},{"title":"kbhit – BlockTran","text":"interface public function kbhit() bind(c, name='_kbhit') Arguments None Return Value integer(kind=c_int)","tags":"","loc":"interface/kbhit.html"},{"title":"initial – BlockTran","text":"function initial(next) result(failed) Arguments Type Intent Optional Attributes Name character, intent(in) :: next Return Value logical Contents None","tags":"","loc":"proc/initial.html"},{"title":"test_floor – BlockTran","text":"function test_floor(next) result(failed) Arguments Type Intent Optional Attributes Name character, intent(in) :: next Return Value logical Contents None","tags":"","loc":"proc/test_floor.html"},{"title":"left_wall – BlockTran","text":"function left_wall(next) result(failed) Arguments Type Intent Optional Attributes Name character, intent(in) :: next Return Value logical Contents None","tags":"","loc":"proc/left_wall.html"},{"title":"right_wall – BlockTran","text":"function right_wall(next) result(failed) Arguments Type Intent Optional Attributes Name character, intent(in) :: next Return Value logical Contents None","tags":"","loc":"proc/right_wall.html"},{"title":"block_hit – BlockTran","text":"function block_hit(next) result(failed) Arguments Type Intent Optional Attributes Name character, intent(in) :: next Return Value logical Contents None","tags":"","loc":"proc/block_hit.html"},{"title":"print_piece – BlockTran","text":"subroutine print_piece(P) Arguments Type Intent Optional Attributes Name class( Piece ), intent(in) :: P Contents None","tags":"","loc":"proc/print_piece.html"},{"title":"print_block – BlockTran","text":"subroutine print_block(B) Arguments Type Intent Optional Attributes Name integer, intent(in) :: B (:,:) Contents None","tags":"","loc":"proc/print_block.html"},{"title":"check_x – BlockTran","text":"subroutine check_x(x) Arguments Type Intent Optional Attributes Name integer, intent(in) :: x (:) Contents None","tags":"","loc":"proc/check_x.html"},{"title":"AI – BlockTran","text":"Uses fields shapes Contents Functions project_down height diff Subroutines AI_input seek_deep down_random move_random Functions public function project_down (F, P) result(y) Arguments Type Intent Optional Attributes Name class( Field ), intent(in) :: F class( Piece ), intent(in) :: P Return Value integer public function height (F, P) Arguments Type Intent Optional Attributes Name class( Field ), intent(in) :: F class( Piece ), intent(in) :: P Return Value integer public pure function diff (A) Arguments Type Intent Optional Attributes Name integer, intent(in) :: A (:) Return Value integer Subroutines public subroutine AI_input (F, P) Arguments Type Intent Optional Attributes Name class( Field ), intent(in) :: F class( Piece ), intent(inout) :: P public subroutine seek_deep (F, P) Arguments Type Intent Optional Attributes Name class( Field ), intent(in) :: F class( Piece ), intent(inout) :: P public subroutine down_random (P) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: P public subroutine move_random (P) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: P","tags":"","loc":"module/ai.html"},{"title":"blocks – BlockTran","text":"Uses cinter shapes fields Contents Subroutines draw_piece freeze game_over Subroutines public subroutine draw_piece (P) Arguments Type Intent Optional Attributes Name class( Piece ), intent(in) :: P public subroutine freeze (F, P, NP) Arguments Type Intent Optional Attributes Name class( Field ), intent(inout) :: F class( Piece ), intent(inout) :: P class( Piece ), intent(inout) :: NP public subroutine game_over (F, P, msg) Arguments Type Intent Optional Attributes Name class( Field ), intent(in) :: F class( Piece ), intent(in), optional :: P character(len=*), intent(in), optional :: msg","tags":"","loc":"module/blocks.html"},{"title":"cinter – BlockTran","text":"Uses iso_c_binding oscinter Contents Variables LINES COLS stdscr curscr FAIL Interfaces f_initscr getch nodelay keypad f_addch printw getmaxyx endwin flushinp timeout mvaddch refresh clear border noecho cbreak mvprintw Functions initscr Subroutines addch Variables Type Visibility Attributes Name Initial integer(kind=c_int), public :: LINES integer(kind=c_int), public :: COLS type(c_ptr), public :: stdscr type(c_ptr), public :: curscr integer(kind=c_int), public, parameter :: FAIL = -1 Interfaces interface public function f_initscr() result(initscr__OUT) bind(C, name='initscr') Arguments None Return Value type(c_ptr) interface public function getch() result(ch) bind(C) Arguments None Return Value integer(kind=c_int) interface public function nodelay(win, bf) result(ierr) bind(C, name='nodelay') http://www.urbanjost.altervista.org/LIBRARY/libscreen/ncurses/pdsrc/ncurses.f90 Arguments Type Intent Optional Attributes Name type(C_PTR), value :: win logical(kind=C_BOOL), value :: bf Return Value integer(kind=C_INT) interface public function keypad(win, bf) result(ierr) bind(C, name='keypad') http://www.urbanjost.altervista.org/LIBRARY/libscreen/ncurses/pdsrc/ncurses.f90 Arguments Type Intent Optional Attributes Name type(C_PTR), value :: win logical(kind=C_BOOL), value :: bf Return Value integer(kind=C_INT) interface public function f_addch(ch) result(addch__OUT) bind(c, name='addch') Arguments Type Intent Optional Attributes Name character(kind=c_char), intent(in), value :: ch Return Value integer(kind=c_int) interface public function printw(str) bind(C) Arguments Type Intent Optional Attributes Name character(kind=c_char), intent(in) :: str Return Value integer(kind=c_int) interface public subroutine getmaxyx(win, y, x) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: win integer(kind=c_int) :: y integer(kind=c_int) :: x interface public subroutine endwin() bind(C) Arguments None interface public subroutine flushinp() bind(c) Arguments None interface public subroutine timeout(delay) bind(C) timeout(0) => non-blocking getch() (-1 if no keypress) Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: delay interface public subroutine mvaddch(y, x, ch) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: y integer(kind=c_int), intent(in), value :: x character(kind=c_char), intent(in), value :: ch interface public subroutine refresh() bind(C) Arguments None interface public subroutine clear() bind(C) clear entire screen Arguments None interface public subroutine border() bind(C) draw border Arguments None interface public subroutine noecho() bind(C) Arguments None interface public subroutine cbreak() bind(C) Arguments None interface public subroutine mvprintw(y, x, str) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: y integer(kind=c_int), intent(in), value :: x character(kind=c_char), intent(in) :: str Functions public function initscr () result(stdscr__OUT) Arguments None Return Value type(C_PTR) Subroutines public subroutine addch (ch) Arguments Type Intent Optional Attributes Name character(kind=c_char), intent(in), value :: ch","tags":"","loc":"module/cinter.html"},{"title":"errs – BlockTran","text":"Uses iso_fortran_env cinter Contents Subroutines err Subroutines public subroutine err (msg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: msg","tags":"","loc":"module/errs.html"},{"title":"fields – BlockTran","text":"Uses iso_c_binding Contents Derived Types Field Subroutines setup levelup clear_lines Derived Types type, public :: Field Components Type Visibility Attributes Name Initial real, public :: move_time = 0.5 integer(kind=c_int), public :: sleep_incr = 50 real, public :: difffact = 1. integer, public :: level = 1 real, public :: diffinc = 1.2 integer, public :: score = 0 integer, public :: Nblock = 0 integer, public :: Ncleared = 0 integer, public :: lines_per_level = 10 integer, public :: bonus (-1:4) = [-100, 0, 40, 100, 300, 1200] character(len=1), public :: blockseq (10000) = \"\" integer, public :: toc integer, public :: tic integer, public :: H integer, public :: W integer, public :: x0 integer, public, allocatable :: screen (:,:) logical, public :: debug = .false. integer, public :: udbg logical, public :: newhit = .false. logical, public :: cheat = .false. logical, public :: AI Type-Bound Procedures procedure, public :: clear_lines procedure, public :: levelup procedure, public :: setup Subroutines private subroutine setup (self, W, H, x0, AI, difffact, debug) Arguments Type Intent Optional Attributes Name class( Field ), intent(inout) :: self integer, intent(in) :: W integer, intent(in) :: H integer, intent(in), optional :: x0 logical, intent(in), optional :: AI real, intent(in), optional :: difffact logical, intent(in), optional :: debug private subroutine levelup (self) Arguments Type Intent Optional Attributes Name class( Field ), intent(inout) :: self private subroutine clear_lines (self) Arguments Type Intent Optional Attributes Name class( Field ), intent(inout) :: self","tags":"","loc":"module/fields.html"},{"title":"game – BlockTran","text":"Uses iso_c_binding menu cinter sleep_std errs blocks shapes fields random keys Contents Variables F trate players update debug difffact Subroutines main_game mainsub redraw cmd_parse draw_screen draw_score Variables Type Visibility Attributes Name Initial type( Field ), public :: F (2) integer, public :: trate integer, public :: players logical, public :: update = .false. logical, public :: debug = .false. real, public :: difffact Subroutines public subroutine main_game (W, H) get tick rae Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: W integer, intent(in) :: H public subroutine mainsub (F, P, NP) time's up, move piece one step down. real(trate) is necessary for float time comparison! Arguments Type Intent Optional Attributes Name class( Field ) :: F type( Piece ) :: P type( Piece ) :: NP public subroutine redraw (F, P, NP) Arguments Type Intent Optional Attributes Name class( Field ), intent(in) :: F class( Piece ), intent(in) :: P class( Piece ), intent(in) :: NP public subroutine cmd_parse (W, H) Arguments Type Intent Optional Attributes Name integer, intent(out) :: W integer, intent(out) :: H public subroutine draw_screen (F) Arguments Type Intent Optional Attributes Name class( Field ), intent(in) :: F public subroutine draw_score (F) Arguments Type Intent Optional Attributes Name class( Field ), intent(in) :: F","tags":"","loc":"module/game.html"},{"title":"keys – BlockTran","text":"Uses iso_c_binding AI cinter blocks shapes fields Contents Subroutines key_input Subroutines public subroutine key_input (F, P, NP) Arguments Type Intent Optional Attributes Name class( Field ), intent(inout) :: F class( Piece ), intent(inout) :: P class( Piece ), intent(inout), optional :: NP","tags":"","loc":"module/keys.html"},{"title":"menu – BlockTran","text":"Uses iso_c_binding iso_fortran_env random cinter sleep_std shapes fields blocks Contents Variables buf y0 L W H Nstates ic Functions makeLetter Subroutines title dissolve Variables Type Visibility Attributes Name Initial character(len=14), public :: buf integer(kind=c_int), public, parameter :: y0 = 5 integer(kind=c_int), public, parameter :: L = 10 integer(kind=c_int), public, parameter :: W = 80 integer(kind=c_int), public, parameter :: H = 60 integer, public :: Nstates integer(kind=c_int), public :: ic Functions public function makeLetter (F, y0, x0, letter) result(S) Arguments Type Intent Optional Attributes Name type( Field ), intent(in) :: F integer(kind=c_int), intent(in) :: y0 integer(kind=c_int), intent(in) :: x0 character, intent(in) :: letter Return Value type( Piece ) Subroutines public subroutine title (Fld) Arguments Type Intent Optional Attributes Name class( Field ), intent(in), optional :: Fld public recursive subroutine dissolve (P) updates random character for each pixel of this piece Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: P","tags":"","loc":"module/menu.html"},{"title":"random – BlockTran","text":"Contents Interfaces std mean Functions randint std_real std_int mean_real mean_int Subroutines rand_init Interfaces public interface std public pure function std_int (A) result(std) Arguments Type Intent Optional Attributes Name integer, intent(in) :: A (:) Return Value real public pure function std_real (A) result(std) Arguments Type Intent Optional Attributes Name real, intent(in) :: A (:) Return Value real public interface mean public pure function mean_int (A) result(mean) Arguments Type Intent Optional Attributes Name integer, intent(in) :: A (:) Return Value real public pure function mean_real (A) result(mean) Arguments Type Intent Optional Attributes Name real, intent(in) :: A (:) Return Value real Functions public impure elemental function randint (lo, hi) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lo integer, intent(in) :: hi Return Value integer public pure function std_real (A) result(std) Arguments Type Intent Optional Attributes Name real, intent(in) :: A (:) Return Value real public pure function std_int (A) result(std) Arguments Type Intent Optional Attributes Name integer, intent(in) :: A (:) Return Value real public pure function mean_real (A) result(mean) Arguments Type Intent Optional Attributes Name real, intent(in) :: A (:) Return Value real public pure function mean_int (A) result(mean) Arguments Type Intent Optional Attributes Name integer, intent(in) :: A (:) Return Value real Subroutines public subroutine rand_init (repeatable, image_distinct) if intrinsic random_init available, use it. Arguments Type Intent Optional Attributes Name logical, intent(in) :: repeatable logical, intent(in) :: image_distinct","tags":"","loc":"module/random.html"},{"title":"rotflip – BlockTran","text":"Uses iso_fortran_env Contents Functions rot90 flip flipud fliplr Functions public function rot90 (A, k) Arguments Type Intent Optional Attributes Name integer, intent(in) :: A (:,:) integer, intent(in), optional :: k Return Value integer public function flip (A, d) Arguments Type Intent Optional Attributes Name integer, intent(in) :: A (:,:) integer, intent(in) :: d Return Value integer public function flipud (A) Arguments Type Intent Optional Attributes Name integer, intent(in) :: A (:,:) Return Value integer public function fliplr (A) Arguments Type Intent Optional Attributes Name integer, intent(in) :: A (:,:) Return Value integer","tags":"","loc":"module/rotflip.html"},{"title":"shapes – BlockTran","text":"Uses iso_fortran_env rotflip fields random Contents Derived Types Piece Functions gen_type check_collision hit_floor hit_horiz hit_block randomx Subroutines init_block spawn_block dissolver move_left move_right move_down rotate vertflip horizflip tell_why Derived Types type, public, extends( Field ) :: Piece Components Type Visibility Attributes Name Initial real, public :: move_time = 0.5 integer(kind=c_int), public :: sleep_incr = 50 real, public :: difffact = 1. integer, public :: level = 1 real, public :: diffinc = 1.2 integer, public :: score = 0 integer, public :: Nblock = 0 integer, public :: Ncleared = 0 integer, public :: lines_per_level = 10 integer, public :: bonus (-1:4) = [-100, 0, 40, 100, 300, 1200] character(len=1), public :: blockseq (10000) = \"\" integer, public :: toc integer, public :: tic integer, public :: H integer, public :: W integer, public :: x0 integer, public, allocatable :: screen (:,:) logical, public :: debug = .false. integer, public :: udbg logical, public :: newhit = .false. logical, public :: cheat = .false. logical, public :: AI character, public :: btype character(len=80), public :: why character, public :: ch (12) integer, public :: Nx integer, public :: Ny integer, public :: x integer, public :: y integer, public, allocatable :: values (:,:) logical, public :: landed logical, public :: movereq Type-Bound Procedures procedure, public :: clear_lines procedure, public :: levelup procedure, public :: setup procedure, public :: horizflip procedure, public :: vertflip procedure, public :: spawn_block procedure, public :: dissolver procedure, public :: move_down procedure, public :: rotate procedure, public :: move_left procedure, public :: move_right procedure, public :: check_collision procedure, public :: init => init_block procedure, private :: hit_block procedure, private :: hit_floor procedure, private :: hit_horiz procedure, private :: tell_why procedure, private :: randomx Functions public function gen_type () result(next) Arguments None Return Value character private function check_collision (self) result(collided) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self Return Value logical private function hit_floor (self) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self Return Value logical private function hit_horiz (self) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self Return Value logical private function hit_block (self) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self Return Value logical private function randomx (self) Arguments Type Intent Optional Attributes Name class( Piece ), intent(in) :: self Return Value integer Subroutines private subroutine init_block (self, F, btype, x, y) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self class( Field ), intent(in) :: F character, intent(in), optional :: btype integer, intent(in), optional :: x integer, intent(in), optional :: y private subroutine spawn_block (self, F, NP) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self class( Field ), intent(inout) :: F class( Piece ), intent(inout), optional :: NP private subroutine dissolver (self) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self private subroutine move_left (self, slam) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self logical, intent(in), optional :: slam private subroutine move_right (self, slam) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self logical, intent(in), optional :: slam private recursive subroutine move_down (self, slam) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self logical, intent(in), optional :: slam private subroutine rotate (self) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self private subroutine vertflip (self) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self private subroutine horizflip (self) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self private subroutine tell_why (self, msg) Arguments Type Intent Optional Attributes Name class( Piece ), intent(in) :: self character(len=*), intent(in), optional :: msg","tags":"","loc":"module/shapes.html"},{"title":"sleep_std – BlockTran","text":"Uses iso_c_binding Contents Interfaces winsleep Subroutines sleep Interfaces interface private subroutine winsleep(dwMilliseconds) bind(C, name=\"0\") void Sleep(DWORD dwMilliseconds)\n https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-sleep Arguments Type Intent Optional Attributes Name integer(kind=c_long), intent(in), value :: dwMilliseconds Subroutines public subroutine sleep (millisec) Arguments Type Intent Optional Attributes Name integer, intent(in) :: millisec","tags":"","loc":"module/sleep_std.html"},{"title":"oscinter – BlockTran","text":"Uses iso_c_binding Contents Functions kbhit Functions public function kbhit () Arguments None Return Value integer(kind=c_int)","tags":"","loc":"module/oscinter.html"},{"title":"oscinter – BlockTran","text":"Uses iso_c_binding Contents Interfaces kbhit Interfaces interface public function kbhit() bind(c, name='_kbhit') Arguments None Return Value integer(kind=c_int)","tags":"","loc":"module/oscinter~2.html"},{"title":"adder – BlockTran","text":"Contents Interfaces addone Interfaces interface function addone(N) bind(C) Arguments Type Intent Optional Attributes Name integer, intent(in), value :: N Return Value integer","tags":"","loc":"program/adder.html"},{"title":"BlockTran – BlockTran","text":"Uses random game Contents Variables W H Variables Type Attributes Name Initial integer :: W integer :: H","tags":"","loc":"program/blocktran.html"},{"title":"keytest – BlockTran","text":"Uses iso_c_binding cinter sleep_std errs Contents Variables stdscr ic ierr buf true Variables Type Attributes Name Initial type(c_ptr) :: stdscr integer(kind=c_int) :: ic integer(kind=c_int) :: ierr character(kind=c_char,len=7) :: buf logical(kind=c_bool), parameter :: true = .true.","tags":"","loc":"program/keytest.html"},{"title":"rand_test – BlockTran","text":"Uses iso_fortran_env shapes random Contents Variables types Ntypes rtol ideal b e f g i n c u buf Variables Type Attributes Name Initial character(len=*), parameter :: types = 'ITLJSZOD' integer, parameter :: Ntypes = len(types) real, parameter :: rtol = 0.05 real :: ideal character, allocatable :: b (:) real, allocatable :: e (:) integer, allocatable :: f (:) integer, allocatable :: g (:) integer :: i integer :: n integer :: c (Ntypes) integer :: u character(len=16) :: buf","tags":"","loc":"program/rand_test.html"},{"title":"test_curses – BlockTran","text":"Uses iso_c_binding cinter sleep_std Contents Variables ierr stdscr Variables Type Attributes Name Initial integer(kind=c_int) :: ierr type(c_ptr) :: stdscr","tags":"","loc":"program/test_curses.html"},{"title":"test_menu – BlockTran","text":"Uses iso_c_binding cinter menu Contents Variables stdscr Variables Type Attributes Name Initial type(c_ptr) :: stdscr","tags":"","loc":"program/test_menu.html"},{"title":"test_motion – BlockTran","text":"Uses iso_fortran_env shapes fields Contents Variables W H Functions initial test_floor left_wall right_wall block_hit Subroutines print_piece print_block Variables Type Attributes Name Initial integer, parameter :: W = 10 integer, parameter :: H = 10 Functions function initial (next) result(failed) Arguments Type Intent Optional Attributes Name character, intent(in) :: next Return Value logical function test_floor (next) result(failed) Arguments Type Intent Optional Attributes Name character, intent(in) :: next Return Value logical function left_wall (next) result(failed) Arguments Type Intent Optional Attributes Name character, intent(in) :: next Return Value logical function right_wall (next) result(failed) Arguments Type Intent Optional Attributes Name character, intent(in) :: next Return Value logical function block_hit (next) result(failed) Arguments Type Intent Optional Attributes Name character, intent(in) :: next Return Value logical Subroutines subroutine print_piece (P) Arguments Type Intent Optional Attributes Name class( Piece ), intent(in) :: P subroutine print_block (B) Arguments Type Intent Optional Attributes Name integer, intent(in) :: B (:,:)","tags":"","loc":"program/test_motion.html"},{"title":"test_shapes – BlockTran","text":"Uses iso_fortran_env shapes fields random Contents Variables F S line tee ell jay ess zee oh Ny Nx W H Ntest i xarr Subroutines check_x Variables Type Attributes Name Initial type( Field ) :: F type( Piece ) :: S type( Piece ) :: line type( Piece ) :: tee type( Piece ) :: ell type( Piece ) :: jay type( Piece ) :: ess type( Piece ) :: zee type( Piece ) :: oh integer, parameter :: Ny = 4 integer, parameter :: Nx = 4 integer, parameter :: W = 6 integer, parameter :: H = 10 integer, parameter :: Ntest = 100 integer :: i integer :: xarr (Ntest) Subroutines subroutine check_x (x) Arguments Type Intent Optional Attributes Name integer, intent(in) :: x (:)","tags":"","loc":"program/test_shapes.html"}]}