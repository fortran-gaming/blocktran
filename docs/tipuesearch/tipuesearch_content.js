var tipuesearch = {"pages":[{"title":" Tetran ","text":"Tetran Developer Info Michael Hirsch Ph.D. SciVision, Inc.","tags":"home","loc":"index.html"},{"title":"random.f90 – Tetran","text":"Files dependent on this one sourcefile~~random.f90~~AfferentGraph sourcefile~random.f90 random.f90 sourcefile~rand.f90 rand.f90 sourcefile~rand.f90->sourcefile~random.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~random.f90 sourcefile~menu.f90 menu.f90 sourcefile~main.f90->sourcefile~menu.f90 sourcefile~shapes.f90 shapes.f90 sourcefile~main.f90->sourcefile~shapes.f90 sourcefile~keys.f90 keys.f90 sourcefile~main.f90->sourcefile~keys.f90 sourcefile~blocks.f90 blocks.f90 sourcefile~main.f90->sourcefile~blocks.f90 sourcefile~rand_legacy.f90 rand_legacy.f90 sourcefile~rand_legacy.f90->sourcefile~random.f90 sourcefile~menu.f90->sourcefile~random.f90 sourcefile~menu.f90->sourcefile~shapes.f90 sourcefile~menu.f90->sourcefile~blocks.f90 sourcefile~test_shapes.f90 test_shapes.f90 sourcefile~test_shapes.f90->sourcefile~random.f90 sourcefile~test_shapes.f90->sourcefile~shapes.f90 sourcefile~shapes.f90->sourcefile~random.f90 sourcefile~randtest.f90 randtest.f90 sourcefile~randtest.f90->sourcefile~random.f90 sourcefile~randtest.f90->sourcefile~shapes.f90 sourcefile~ai.f90 ai.f90 sourcefile~ai.f90->sourcefile~shapes.f90 sourcefile~keys.f90->sourcefile~shapes.f90 sourcefile~keys.f90->sourcefile~ai.f90 sourcefile~keys.f90->sourcefile~blocks.f90 sourcefile~test_motion.f90 test_motion.f90 sourcefile~test_motion.f90->sourcefile~shapes.f90 sourcefile~blocks.f90->sourcefile~shapes.f90 sourcefile~test_menu.f90 test_menu.f90 sourcefile~test_menu.f90->sourcefile~menu.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules random Source Code random.f90 Source Code module random use , intrinsic :: iso_fortran_env , only : stderr => error_unit implicit none interface std procedure std_int , std_real end interface interface mean procedure mean_int , mean_real end interface !interface !  module subroutine random_init() !  end subroutine !end interface contains impure elemental integer function randint ( lo , hi ) integer , intent ( in ) :: lo , hi real :: r call random_number ( r ) randint = floor ( r * ( hi + 1 - lo )) + lo end function randint !========================================= pure real function std_real ( A ) result ( std ) real , intent ( in ) :: A (:) std = sqrt ( sum ( abs ( A - mean ( A )) ** 2 ) / ( size ( A ) - 1 )) end function std_real pure real function std_int ( A ) result ( std ) integer , intent ( in ) :: A (:) std = sqrt ( sum ( abs ( A - mean ( A )) ** 2 ) / size ( A )) end function std_int !============================================== pure real function mean_real ( A ) result ( mean ) real , intent ( in ) :: A (:) mean = sum ( A ) / size ( A ) end function mean_real pure real function mean_int ( A ) result ( mean ) integer , intent ( in ) :: A (:) mean = sum ( A ) / real ( size ( A )) ! real coerces end function mean_int subroutine random_init ! NOTE: this subroutine is replaced by \"call random_init()\" in Fortran 2018 integer :: i , n , u , ios integer , allocatable :: seed (:) character ( * ), parameter :: randfn = '/dev/urandom' call random_seed ( size = n ) allocate ( seed ( n )) open ( newunit = u , file = randfn , access = \"stream\" , form = \"unformatted\" , action = \"read\" , status = \"old\" , iostat = ios ) if ( ios == 0 ) then read ( u , iostat = ios ) seed close ( u ) endif if ( ios /= 0 ) then write ( stderr , * ) 'falling back to internal random number generator' do i = 1 , n seed ( i ) = randint ( - 1073741823 , 1073741823 ) enddo endif call random_seed ( put = seed ) end subroutine random_init end module random","tags":"","loc":"sourcefile/random.f90.html"},{"title":"ai.f90 – Tetran","text":"This file depends on sourcefile~~ai.f90~~EfferentGraph sourcefile~ai.f90 ai.f90 sourcefile~shapes.f90 shapes.f90 sourcefile~ai.f90->sourcefile~shapes.f90 sourcefile~fields.f90 fields.f90 sourcefile~ai.f90->sourcefile~fields.f90 sourcefile~shapes.f90->sourcefile~fields.f90 sourcefile~rot90.f90 rot90.f90 sourcefile~shapes.f90->sourcefile~rot90.f90 sourcefile~random.f90 random.f90 sourcefile~shapes.f90->sourcefile~random.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~ai.f90~~AfferentGraph sourcefile~ai.f90 ai.f90 sourcefile~keys.f90 keys.f90 sourcefile~keys.f90->sourcefile~ai.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~keys.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules AI Source Code ai.f90 Source Code module AI use fields , only : field use shapes , only : piece implicit none contains subroutine AI_input ( F , P ) class ( field ), intent ( in ) :: F class ( piece ), intent ( inout ) :: P ! check if easy case--clear to bottom (FIXME: predict outcome) if ( project_down ( F , P ) >= F % H - P % Ny ) then call down_random ( P ) return endif ! harder cases call seek_deep ( F , P ) end subroutine AI_input integer function project_down ( F , P ) result ( y ) ! returns freezing Y position for this ONE piece X position class ( field ), intent ( in ) :: F class ( piece ), intent ( in ) :: P type ( piece ) :: T integer :: i , j , h ( 4 ) ! create test piece call T % init ( F , P % btype , x = P % x , y = P % y ) ! see how low the piece can go for this X position y = F % H h = 1 rot : do i = 1 , size ( h ) call T % rotate () hght : do j = 1 , F % H T % y = j if ( T % check_collision ()) then h ( i ) = j - 1 exit hght endif enddo hght enddo rot where ( h == 1 ) h = 9999 y = min ( y , maxval ( h )) end function project_down subroutine seek_deep ( F , P ) class ( field ), intent ( in ) :: F class ( piece ), intent ( inout ) :: P integer :: k ( 1 ), x_center , x_seek real :: r real , parameter :: dumbness = 0. ! 0..1  lower number, less dumb !-- maybe do something random instead of smart call random_number ( r ) if ( r < dumbness ) then ! act randomly instead call move_random ( P ) return endif !-- compute smarter action x_center = P % x - P % Nx / 2 ! FIXME: approximately, what about rotated \"I\" ! for now, seek the \"deepest\" place k = maxloc ( height ( F , P )) x_seek = k ( 1 ) !--- take action if ( x_seek <= x_center ) then call P % move_left () elseif ( x_seek >= x_center ) then call P % move_right () endif end subroutine seek_deep subroutine down_random ( P ) class ( piece ), intent ( inout ) :: P real :: r integer :: i call random_number ( r ) if ( r >= 0 . and . r < 0.25 ) then call random_number ( r ) do i = 1 , floor ( 2 * r ) call P % move_down () enddo elseif ( r >= 0.25 . and . r < 0.3 ) then call P % move_down ( slam = . true .) endif end subroutine down_random subroutine move_random ( P ) class ( piece ), intent ( inout ) :: P real :: r integer :: i real , parameter :: patience = 0.9 ! 0..1 if > patience, move. call random_number ( r ) if ( r < patience ) return call random_number ( r ) if ( r < 0.33 ) then call P % move_left () elseif ( r >= 0.33 . and . r < 0.66 ) then call P % move_right () else call P % rotate () call random_number ( r ) if ( r >= 0 . and . r < 0.25 ) then do i = 1 , floor ( 8 * r ) call P % move_left () enddo elseif ( r >= 0.25 . and . r < 0.5 ) then do i = 1 , floor ( 8 * r ) call P % move_right () enddo endif endif end subroutine move_random integer function height ( F , P ) ! \"Height\" in tetran is distance from top of screen -- smaller is higher ! checks how well piece fits class ( field ), intent ( in ) :: F class ( piece ), intent ( in ) :: P dimension :: height ( P % W ) integer :: i type ( piece ) :: T ! create test piece call T % init ( F , P % btype , x = P % x , y = P % y ) do i = 1 , F % W T % x = i height ( i ) = project_down ( F , T ) enddo where ( height == 1 ) height = 9999 end function height pure integer function diff ( A ) ! first difference integer , intent ( in ) :: A (:) dimension :: diff ( size ( A )) diff = A ( 2 :) - A (: size ( A ) - 1 ) end function diff end module AI","tags":"","loc":"sourcefile/ai.f90.html"},{"title":"rot90.f90 – Tetran","text":"Files dependent on this one sourcefile~~rot90.f90~~AfferentGraph sourcefile~rot90.f90 rot90.f90 sourcefile~shapes.f90 shapes.f90 sourcefile~shapes.f90->sourcefile~rot90.f90 sourcefile~ai.f90 ai.f90 sourcefile~ai.f90->sourcefile~shapes.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~shapes.f90 sourcefile~menu.f90 menu.f90 sourcefile~main.f90->sourcefile~menu.f90 sourcefile~keys.f90 keys.f90 sourcefile~main.f90->sourcefile~keys.f90 sourcefile~blocks.f90 blocks.f90 sourcefile~main.f90->sourcefile~blocks.f90 sourcefile~menu.f90->sourcefile~shapes.f90 sourcefile~menu.f90->sourcefile~blocks.f90 sourcefile~keys.f90->sourcefile~shapes.f90 sourcefile~keys.f90->sourcefile~ai.f90 sourcefile~keys.f90->sourcefile~blocks.f90 sourcefile~test_shapes.f90 test_shapes.f90 sourcefile~test_shapes.f90->sourcefile~shapes.f90 sourcefile~test_motion.f90 test_motion.f90 sourcefile~test_motion.f90->sourcefile~shapes.f90 sourcefile~blocks.f90->sourcefile~shapes.f90 sourcefile~randtest.f90 randtest.f90 sourcefile~randtest.f90->sourcefile~shapes.f90 sourcefile~test_menu.f90 test_menu.f90 sourcefile~test_menu.f90->sourcefile~menu.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules rotflip Source Code rot90.f90 Source Code module rotflip ! This module provides rot90, flipud, fliplr for Fortran like Matlab and NumPy ! use , intrinsic :: iso_fortran_env , only : stderr => error_unit implicit none contains integer function rot90 ( A , k ) ! https://github.com/numpy/numpy/blob/v1.14.2/numpy/lib/function_base.py#L54-L138 integer , intent ( in ) :: A (:,:) integer , intent ( in ), optional :: k dimension :: rot90 ( size ( A , 1 ), size ( A , 2 )) integer :: r r = 1 if ( present ( k )) r = k select case ( modulo ( r , 4 )) case ( 0 ) rot90 = A ! unmodified case ( 1 ) rot90 = transpose ( flip ( A , 1 )) case ( 2 ) rot90 = flip ( A , 0 ) case ( 3 ) rot90 = flip ( transpose ( A ), 1 ) end select end function rot90 integer function flip ( A , d ) integer , intent ( in ) :: A (:,:) integer , intent ( in ) :: d integer :: M , N dimension :: flip ( size ( A , 1 ), size ( A , 2 )) M = size ( A , 1 ) N = size ( A , 2 ) select case ( d ) case ( 0 ) ! flip both dimensions flip = A ( M : 1 : - 1 , N : 1 : - 1 ) case ( 1 ) flip = A ( M : 1 : - 1 , :) case ( 2 ) flip = A (:, N : 1 : - 1 ) case default write ( stderr , * ) 'bad flip dimension, 2-D only  (1 or 2), or 0 for both dimensions' end select end function flip integer function flipud ( A ) integer , intent ( in ) :: A (:,:) dimension :: flipud ( size ( A , 1 ), size ( A , 2 )) flipud = flip ( A , 1 ) end function flipud integer function fliplr ( A ) integer , intent ( in ) :: A (:,:) dimension :: fliplr ( size ( A , 1 ), size ( A , 2 )) fliplr = flip ( A , 2 ) end function fliplr end module rotflip","tags":"","loc":"sourcefile/rot90.f90.html"},{"title":"shapes.f90 – Tetran","text":"This file depends on sourcefile~~shapes.f90~~EfferentGraph sourcefile~shapes.f90 shapes.f90 sourcefile~rot90.f90 rot90.f90 sourcefile~shapes.f90->sourcefile~rot90.f90 sourcefile~fields.f90 fields.f90 sourcefile~shapes.f90->sourcefile~fields.f90 sourcefile~random.f90 random.f90 sourcefile~shapes.f90->sourcefile~random.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~shapes.f90~~AfferentGraph sourcefile~shapes.f90 shapes.f90 sourcefile~ai.f90 ai.f90 sourcefile~ai.f90->sourcefile~shapes.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~shapes.f90 sourcefile~menu.f90 menu.f90 sourcefile~main.f90->sourcefile~menu.f90 sourcefile~keys.f90 keys.f90 sourcefile~main.f90->sourcefile~keys.f90 sourcefile~blocks.f90 blocks.f90 sourcefile~main.f90->sourcefile~blocks.f90 sourcefile~menu.f90->sourcefile~shapes.f90 sourcefile~menu.f90->sourcefile~blocks.f90 sourcefile~keys.f90->sourcefile~shapes.f90 sourcefile~keys.f90->sourcefile~ai.f90 sourcefile~keys.f90->sourcefile~blocks.f90 sourcefile~test_shapes.f90 test_shapes.f90 sourcefile~test_shapes.f90->sourcefile~shapes.f90 sourcefile~test_motion.f90 test_motion.f90 sourcefile~test_motion.f90->sourcefile~shapes.f90 sourcefile~blocks.f90->sourcefile~shapes.f90 sourcefile~randtest.f90 randtest.f90 sourcefile~randtest.f90->sourcefile~shapes.f90 sourcefile~test_menu.f90 test_menu.f90 sourcefile~test_menu.f90->sourcefile~menu.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules shapes Source Code shapes.f90 Source Code module shapes use , intrinsic :: iso_fortran_env , only : stdout => output_unit , stderr => error_unit use rotflip , only : rot90 , fliplr , flipud use fields , only : field use random , only : randint implicit none private type , extends ( Field ), public :: Piece character :: btype character ( 80 ) :: why character :: ch ( 12 ) integer :: Nx , Ny ! dims of current realization of piece integer :: x , y ! location of piece in playfield integer , allocatable :: values (:,:) ! pixels of piece (third dim is rotation) logical :: landed ! this piece cannot move anymore logical :: movereq ! piece has requested to move in any direction, need to evaluate if collision first. contains ! one per line for PGI, Flang procedure , public :: init => init_block procedure , private :: init_block procedure , public :: check_collision procedure , public :: move_right procedure , public :: move_left procedure , public :: rotate procedure , public :: move_down procedure , public :: dissolver procedure , public :: spawn_block procedure , public :: vertflip procedure , public :: horizflip procedure , private :: randomx procedure , private :: tell_why procedure , private :: hit_horiz procedure , private :: hit_floor procedure , private :: hit_block end type public :: gen_type ! for benchmarking contains subroutine init_block ( self , F , btype , x , y ) class ( Piece ), intent ( inout ) :: self class ( field ), intent ( in ) :: F character , intent ( in ), optional :: btype integer , intent ( in ), optional :: x , y integer :: i , j integer , parameter :: Nl = 10 ! Flang / PGF chokes on backslash, so do achar(92). ! also FLang / PGF wants defined length. character , parameter :: ch ( 12 ) = [ \"#\" , \"$\" , \"@\" , \"%\" , \"&\" , \"&#94;\" , \"-\" , \"/\" , \"|\" , achar ( 92 ), \"*\" , \".\" ] ! dynamic generated shapes integer :: line ( 4 , 4 ) = 0 integer :: tee ( 3 , 3 ) = 0 integer :: ell ( 3 , 3 ) = 0 integer :: jay ( 3 , 3 ) = 0 integer :: ess ( 3 , 3 ) = 0 integer :: zee ( 3 , 3 ) = 0 integer :: oh ( 2 , 2 ) = 1 integer :: dot ( 1 , 1 ) = 1 integer :: Lt ( Nl , Nl ) = 0 integer :: Le ( Nl , Nl ) = 0 integer :: Lr ( Nl , Nl ) = 0 integer :: La ( Nl , Nl ) = 0 integer :: Ln ( Nl , Nl ) = 0 !----- line ( 2 ,:) = 1 tee ( 2 ,:) = 1 tee ( 3 , 2 ) = 1 ell ( 2 , 1 : 3 ) = 1 ell ( 3 , 1 ) = 1 jay ( 2 , 1 : 3 ) = 1 jay ( 3 , 3 ) = 1 ess ( 2 , 2 : 3 ) = 1 ess ( 3 , 1 : 2 ) = 1 zee ( 2 , 1 : 2 ) = 1 zee ( 3 , 2 : 3 ) = 1 Lt ( 1 ,:) = 1 Lt (:, Nl / 2 ) = 1 Le ( :: Nl / 2 ,:) = 1 Le ( Nl ,:) = 1 Le (:, 1 ) = 1 Lr ( :: Nl / 2 ,:) = 1 Lr (:, 1 ) = 1 Lr ( 1 : Nl / 2 , Nl ) = 1 j = Nl / 2 do i = Nl / 2 + 1 , Nl j = j + 1 Lr ( i , j ) = 1 enddo La (:, 1 ) = 1 La (:, Nl ) = 1 La (: Nl - 1 : Nl / 2 ,:) = 1 Ln (:, 1 ) = 1 Ln (:, Nl ) = 1 j = 0 do i = 1 , Nl j = j + 1 Ln ( i , j ) = 1 enddo !=============================================================================== if (. not . allocated ( F % screen )) error stop 'must initialize playfield before piece' self % screen = F % screen self % W = size ( self % screen , 2 ) self % H = size ( self % screen , 1 ) self % x0 = F % x0 self % landed = . false . self % movereq = . false . self % y = - 1 if ( present ( y )) self % y = y self % ch = ch if ( present ( btype )) then self % btype = btype else self % btype = gen_type () endif ! Fortran 2003+ allocate-on-assign select case ( self % btype ) case ( \"I\" ) self % values = line case ( \"T\" ) self % values = tee case ( \"L\" ) self % values = ell case ( \"J\" ) self % values = jay case ( \"S\" ) self % values = ess case ( \"Z\" ) self % values = zee case ( \"O\" ) self % values = oh case ( \"D\" ) self % values = dot case ( \"t\" ) self % values = Lt case ( \"e\" ) self % values = Le case ( \"r\" ) self % values = Lr case ( \"a\" ) self % values = La case ( \"n\" ) self % values = Ln case default write ( stderr , * ) 'unknown shape ' // self % btype error stop end select self % Ny = size ( self % values , 1 ) self % Nx = size ( self % values , 2 ) !-------- must come after self%Nx assigned! self % x = self % randomx () if ( present ( x )) self % x = x !-------- if ( self % debug ) then print * , 'shape ' , self % btype , ': Ny,Nx ' , self % Ny , self % Nx endif end subroutine init_block subroutine spawn_block ( self , F , NP ) class ( piece ), intent ( inout ) :: self class ( field ), intent ( inout ) :: F class ( piece ), intent ( inout ), optional :: NP integer :: ib ! make new current piece -- have to do this since \"=\" copys pointers, NOT deep copy for derived types! call self % init ( F , NP % btype ) call NP % init ( F , x = F % W + 5 , y = F % H / 2 ) ! track block count F % Nblock = F % Nblock + 1 ! for game stats ! ----- logging --------- if ( F % Nblock > size ( F % blockseq )) then ib = size ( F % blockseq ) F % blockseq = eoshift ( F % blockseq , 1 ) !OK array-temp else ib = F % Nblock endif F % blockseq ( ib ) = self % btype ! ------ end logging end subroutine spawn_block character function gen_type () result ( next ) ! not elemental because there is no input argument. No need for elemental (could be made so as subroutine) character , parameter :: Btypes ( 8 ) = [ 'I' , 'T' , 'L' , 'J' , 'S' , 'Z' , 'O' , 'D' ] next = Btypes ( randint ( 1 , size ( Btypes ))) end function gen_type subroutine dissolver ( self ) class ( Piece ), intent ( inout ) :: self where ( self % values /= 0 ) self % values = modulo ( self % values + 1 , size ( self % ch ) + 1 ) endwhere end subroutine dissolver subroutine move_left ( self , slam ) class ( Piece ), intent ( inout ) :: self logical , intent ( in ), optional :: slam integer :: i if ( present ( slam )) then if ( slam ) then do i = 1 , self % W self % x = self % x - 1 if ( self % check_collision ()) then self % x = self % x + 1 return endif enddo endif endif !-- one pixel move left attempt self % x = self % x - 1 if ( self % check_collision ()) then self % x = self % x + 1 call self % tell_why () endif end subroutine move_left subroutine move_right ( self , slam ) class ( Piece ), intent ( inout ) :: self logical , intent ( in ), optional :: slam integer :: i if ( present ( slam )) then if ( slam ) then do i = 1 , self % W self % x = self % x + 1 if ( self % check_collision ()) then self % x = self % x - 1 return endif enddo endif endif self % x = self % x + 1 if ( self % check_collision ()) then self % x = self % x - 1 call self % tell_why () endif end subroutine move_right recursive subroutine move_down ( self , slam ) class ( Piece ), intent ( inout ) :: self logical , intent ( in ), optional :: slam if ( self % landed ) then self % why = 'no movement allowed after landing' return endif if ( present ( slam )) then if ( slam ) then do while (. not . self % landed ) call self % move_down () enddo return endif endif ! move down 1 pixel self % y = self % y + 1 if ( self % check_collision ()) then ! landed self % landed = . true . self % y = self % y - 1 call self % tell_why () endif end subroutine move_down subroutine rotate ( self ) class ( Piece ), intent ( inout ) :: self self % values = rot90 ( self % values , 1 ) if ( self % check_collision ()) then call self % tell_why ( 'NO rotation:' ) self % values = rot90 ( self % values , - 1 ) endif end subroutine rotate subroutine vertflip ( self ) class ( Piece ), intent ( inout ) :: self self % values = flipud ( self % values ) if ( self % check_collision ()) then call self % tell_why ( 'NO vertical flip:' ) self % values = flipud ( self % values ) endif end subroutine vertflip subroutine horizflip ( self ) class ( Piece ), intent ( inout ) :: self self % values = fliplr ( self % values ) if ( self % check_collision ()) then call self % tell_why ( 'NO horizontal flip:' ) self % values = fliplr ( self % values ) endif end subroutine horizflip logical function check_collision ( self ) result ( collided ) class ( Piece ), intent ( inout ) :: self ! always check all, in case rotation collided = self % hit_floor () if ( collided ) return collided = self % hit_horiz () if ( collided ) return collided = self % hit_block () end function check_collision logical function hit_floor ( self ) ! NOTE: do NOT set self%alanded in this function, as this will break rotation attempts near floor! class ( Piece ), intent ( inout ) :: self integer :: i hit_floor = . false . do i = 1 , self % Ny if ( all ( self % values ( i ,:) == 0 )) cycle hit_floor = self % y + ( i - 1 ) > self % H if ( hit_floor ) exit enddo if ( hit_floor ) then write ( self % why , '(A20,I3,A3,I3)' ) 'floor hit, y0=' , self % y , 'y=' , self % y + ( i - 1 ) endif end function hit_floor logical function hit_horiz ( self ) class ( Piece ), intent ( inout ) :: self integer :: i hit_horiz = . false . do i = 1 , self % Nx if ( all ( self % values (:, i ) == 0 )) cycle hit_horiz = self % x + ( i - 1 ) < 1 . or . self % x + ( i - 1 ) > self % W if ( hit_horiz ) exit enddo if ( hit_horiz ) write ( self % why , '(A21,I3,A3,I3)' ) 'wall hit, x0=' , self % x , 'x=' , self % x + ( i - 1 ) end function hit_horiz logical function hit_block ( self ) class ( Piece ), intent ( inout ) :: self integer :: i , ix , ixs hit_block = . false . ix = max ( 1 , self % x ) ixs = min ( self % W , ix + self % Nx - ( ix - self % x ) - 1 ) do i = 1 , self % Ny if ( self % y + ( i - 1 ) < 1 ) cycle ! this block row above playfield if ( all ( self % values ( i ,:) == 0 )) cycle ! no part of block in this block row hit_block = any ( self % screen ( self % y + ( i - 1 ), ix : ixs ) + self % values ( i , ix - self % x + 1 : ixs - self % x + 1 ) > & maxval ( self % values ( i , ix - self % x + 1 : ixs - self % x + 1 ))) if ( hit_block ) exit enddo if ( hit_block ) write ( self % why , '(A20,I3,A4,I3)' ) 'block hit, x=' , self % x , ' y=' , self % y end function hit_block integer function randomx ( self ) !! NOTE: even if elemental, because it's part of a class, have to %init() then %randomx() !!    each time, if using externally (which would be unusual) class ( Piece ), intent ( in ) :: self if ( self % W == 0 ) error stop 'playfield has zero width. Be sure to intialize playfield before piece?' if (. not . allocated ( self % values )) error stop 'piece was not allocated' if ( self % Nx < 1 . or . self % Nx >= self % W ) then write ( stderr , '(A,I3,A,I3)' ) 'Nx' , self % Nx , '  W' , self % W error stop 'piece outside playfield @ initial x position' endif randomx = randint ( 1 , self % W - self % Nx ) ! 1 to screen width, minus block width end function randomx subroutine tell_why ( self , msg ) class ( Piece ), intent ( in ) :: self character ( * ), intent ( in ), optional :: msg character (:), allocatable :: str if (. not . self % debug ) return if ( present ( msg )) then str = trim ( msg ) // ' ' // trim ( self % why ) else str = self % why endif write ( stdout , '(A50,A1)' , advance = 'no' ) str , achar ( 13 ) flush ( stdout ) end subroutine tell_why end module shapes","tags":"","loc":"sourcefile/shapes.f90.html"},{"title":"cinter.f90 – Tetran","text":"Files dependent on this one sourcefile~~cinter.f90~~AfferentGraph sourcefile~cinter.f90 cinter.f90 sourcefile~err.f90 err.F90 sourcefile~err.f90->sourcefile~cinter.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~cinter.f90 sourcefile~main.f90->sourcefile~err.f90 sourcefile~menu.f90 menu.f90 sourcefile~main.f90->sourcefile~menu.f90 sourcefile~keys.f90 keys.f90 sourcefile~main.f90->sourcefile~keys.f90 sourcefile~blocks.f90 blocks.f90 sourcefile~main.f90->sourcefile~blocks.f90 sourcefile~menu.f90->sourcefile~cinter.f90 sourcefile~menu.f90->sourcefile~blocks.f90 sourcefile~keys.f90->sourcefile~cinter.f90 sourcefile~keys.f90->sourcefile~blocks.f90 sourcefile~blocks.f90->sourcefile~cinter.f90 sourcefile~test_menu.f90 test_menu.f90 sourcefile~test_menu.f90->sourcefile~cinter.f90 sourcefile~test_menu.f90->sourcefile~menu.f90 sourcefile~keytest.f90 keytest.f90 sourcefile~keytest.f90->sourcefile~cinter.f90 sourcefile~keytest.f90->sourcefile~err.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules cinter Source Code cinter.f90 Source Code module cinter use , intrinsic :: iso_c_binding , only : c_int , c_char , c_ptr implicit none integer ( c_int ) :: LINES , COLS type ( c_ptr ) :: stdscr , curscr integer ( c_int ), parameter :: FAIL = - 1 interface !--- function that use cinter.c ! http://www.urbanjost.altervista.org/LIBRARY/libscreen/ncurses/pdsrc/ncurses_from_Fortran.html function f_initscr () result ( initscr__OUT ) bind ( C , name = 'initscr' ) import type ( c_ptr ) :: initscr__OUT ! WINDOW *initscr end function f_initscr subroutine getmaxyx ( win , y , x ) bind ( C , name = 'macro_getmaxyx' ) import type ( c_ptr ), value :: win integer ( c_int ) :: y , x end subroutine getmaxyx !--- functions that interface directly with Curses subroutine endwin () bind ( C ) ! ncurses restores previous terminal contents (before program was run) end subroutine endwin integer ( c_int ) function getch () result ( ch ) bind ( C ) import end function getch subroutine flushinp () bind ( c ) end subroutine flushinp subroutine timeout ( delay ) bind ( C ) import integer ( c_int ), value :: delay end subroutine timeout integer ( c_int ) function f_addch ( ch ) result ( addch__OUT ) bind ( c , name = 'addch' ) import character ( kind = c_char ) , value , intent ( in ) :: ch end function f_addch subroutine mvaddch ( y , x , ch ) bind ( C , name = 'mvaddch' ) import integer ( c_int ), intent ( in ), value :: y , x character ( kind = c_char ), intent ( in ), value :: ch end subroutine mvaddch subroutine refresh () bind ( C , name = 'refresh' ) end subroutine refresh subroutine clear () bind ( C ) end subroutine clear subroutine noecho () bind ( C ) ! don't echo keypresses to screen end subroutine noecho subroutine cbreak () bind ( C ) ! disable line buffer end subroutine cbreak subroutine mvprintw ( y , x , str ) bind ( C ) import integer ( c_int ), intent ( in ), value :: y , x character ( kind = c_char ), intent ( in ) :: str end subroutine mvprintw subroutine usleep ( time ) bind ( C ) import integer ( c_int ), value :: time end subroutine usleep end interface contains function initscr () result ( stdscr__OUT ) ! call initscr() but set global variables too ! http://www.urbanjost.altervista.org/LIBRARY/libscreen/ncurses/pdsrc/ncurses_from_Fortran.html type ( C_PTR ) :: stdscr__OUT stdscr = f_initscr () !stdscr=returnstd() !curscr=returncur() stdscr__OUT = stdscr call getmaxyx ( stdscr , LINES , COLS ) end function initscr subroutine addch ( ch ) character ( kind = c_char ), value , intent ( in ) :: ch ! const chtype ch integer ( c_int ) :: addch__OUT addch__OUT = f_addch ( ch ) if ( addch__OUT == FAIL ) error stop 'addch' end subroutine addch end module cinter","tags":"","loc":"sourcefile/cinter.f90.html"},{"title":"keys.f90 – Tetran","text":"This file depends on sourcefile~~keys.f90~~EfferentGraph sourcefile~keys.f90 keys.f90 sourcefile~ai.f90 ai.f90 sourcefile~keys.f90->sourcefile~ai.f90 sourcefile~fields.f90 fields.f90 sourcefile~keys.f90->sourcefile~fields.f90 sourcefile~blocks.f90 blocks.f90 sourcefile~keys.f90->sourcefile~blocks.f90 sourcefile~shapes.f90 shapes.f90 sourcefile~keys.f90->sourcefile~shapes.f90 sourcefile~cinter.f90 cinter.f90 sourcefile~keys.f90->sourcefile~cinter.f90 sourcefile~ai.f90->sourcefile~fields.f90 sourcefile~ai.f90->sourcefile~shapes.f90 sourcefile~blocks.f90->sourcefile~fields.f90 sourcefile~blocks.f90->sourcefile~shapes.f90 sourcefile~blocks.f90->sourcefile~cinter.f90 sourcefile~shapes.f90->sourcefile~fields.f90 sourcefile~rot90.f90 rot90.f90 sourcefile~shapes.f90->sourcefile~rot90.f90 sourcefile~random.f90 random.f90 sourcefile~shapes.f90->sourcefile~random.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~keys.f90~~AfferentGraph sourcefile~keys.f90 keys.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~keys.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules keys Source Code keys.f90 Source Code module keys use ai , only : AI_input use cinter , only : getch , flushinp use blocks , only : game_over use shapes , only : piece use fields , only : field implicit none contains subroutine key_input ( F , P , NP ) class ( field ), intent ( inout ) :: F class ( piece ), intent ( inout ) :: P class ( piece ), intent ( inout ), optional :: NP integer :: i if ( P % landed ) error stop 'should not have requested input after landing' if ( F % AI ) then call AI_input ( F , P ) return endif i = getch () ! esc is first part of three part arrow key sequence if ( i == 27 ) then i = getch () if ( i == 91 ) then i = getch () select case ( i ) case ( 65 ) i = iachar ( \"w\" ) case ( 68 ) i = iachar ( \"a\" ) case ( 66 ) i = iachar ( \"s\" ) case ( 67 ) i = iachar ( \"d\" ) end select endif endif P % movereq = . true . ! rather than typing it for each case select case ( i ) case ( iachar ( \"a\" )) ! A - left call P % move_left () case ( iachar ( \"l\" )) ! L - slam left call P % move_left ( slam = . true .) case ( iachar ( \"s\" )) ! S - down call P % move_down () case ( iachar ( \"x\" )) ! X - slam down call P % move_down ( slam = . true .) case ( iachar ( \"d\" )) ! D - right call P % move_right () case ( iachar ( \"r\" )) ! R - slam right call P % move_right ( slam = . true .) case ( iachar ( \"w\" )) ! W - rotate call P % rotate () case ( iachar ( \"v\" )) ! W - rotate call P % vertflip () case ( iachar ( \"h\" )) ! W - rotate call P % horizflip () case ( iachar ( \"q\" )) ! Q - quit call game_over ( F ) case ( iachar ( \"t\" )) ! CHEAT   T - reset current piece position y to top, preserving x position P % y = 0 F % cheat = . true . case ( iachar ( \"n\" )) ! CHEAT    N - pick a new piece type for the NEXT block if ( present ( NP )) then call NP % init ( F , x = F % W + 5 , y = F % H / 2 ) endif F % cheat = . true . case ( iachar ( \"c\" )) ! CHEAT  C - clear lowest line (subtract 100 points as penalty) F % screen ( F % H ,:) = 1 call F % clear_lines () P % screen = F % screen ! since we didn't generate a new piece (alternatively, could have made a new piece right here) F % cheat = . true . case default ! do nothing P % movereq = . false . end select call flushinp () ! clear repeating keys from stdin buffer end subroutine key_input end module keys","tags":"","loc":"sourcefile/keys.f90.html"},{"title":"blocks.f90 – Tetran","text":"This file depends on sourcefile~~blocks.f90~~EfferentGraph sourcefile~blocks.f90 blocks.f90 sourcefile~cinter.f90 cinter.f90 sourcefile~blocks.f90->sourcefile~cinter.f90 sourcefile~fields.f90 fields.f90 sourcefile~blocks.f90->sourcefile~fields.f90 sourcefile~shapes.f90 shapes.f90 sourcefile~blocks.f90->sourcefile~shapes.f90 sourcefile~shapes.f90->sourcefile~fields.f90 sourcefile~rot90.f90 rot90.f90 sourcefile~shapes.f90->sourcefile~rot90.f90 sourcefile~random.f90 random.f90 sourcefile~shapes.f90->sourcefile~random.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~blocks.f90~~AfferentGraph sourcefile~blocks.f90 blocks.f90 sourcefile~menu.f90 menu.f90 sourcefile~menu.f90->sourcefile~blocks.f90 sourcefile~keys.f90 keys.f90 sourcefile~keys.f90->sourcefile~blocks.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~blocks.f90 sourcefile~main.f90->sourcefile~menu.f90 sourcefile~main.f90->sourcefile~keys.f90 sourcefile~test_menu.f90 test_menu.f90 sourcefile~test_menu.f90->sourcefile~menu.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules blocks Source Code blocks.f90 Source Code module blocks use cinter , only : mvaddch , endwin use shapes , only : Piece use fields , only : field implicit none private public :: game_over , draw_piece , freeze contains subroutine draw_piece ( P ) class ( piece ), intent ( in ) :: P integer :: i , j , x , y ! not concurrent since \"mvaddch\" remembers its position do i = 1 , P % Ny y = ( i - 1 ) + P % y if ( y < 0 ) cycle do j = 1 , P % Nx x = ( j - 1 ) + P % x if ( P % values ( i , j ) /= 0 ) then ! zero-indexed, so another -1 call mvaddch ( y = y - 1 , x = ( P % x0 - 1 ) + x - 1 , & ch = P % ch ( P % values ( i , j ))) endif end do end do end subroutine draw_piece subroutine freeze ( F , P , NP ) ! Called when a piece has hit another and freezes class ( piece ), intent ( inout ) :: P , NP class ( field ), intent ( inout ) :: F integer :: i , y , ix , x , Nx , ixs character ( 120 ) :: buf if (. not . P % landed ) return x = P % x Nx = P % Nx ! not concurrent due to impure \"game over\" ix = max ( 1 , x ) ixs = min ( F % W , ix + Nx - ( ix - x ) - 1 ) do i = 1 , P % Ny if ( all ( P % values ( i , :) == 0 )) cycle y = i - 1 + P % y if ( y <= 1 ) then write ( buf , '(A12,I3,A3,I3)' ) 'freeze: x=' , x , 'y=' , y call game_over ( F , P , buf ) endif where ( F % screen ( y , ix : ixs ) == 1 . or . P % values ( i , ix - x + 1 : ixs - x + 1 ) == 1 ) F % screen ( y , ix : ixs ) = 1 endwhere end do call F % clear_lines () call P % spawn_block ( F , NP ) end subroutine freeze subroutine game_over ( F , P , msg ) class ( field ), intent ( in ) :: F class ( piece ), intent ( in ), optional :: P character ( * ), intent ( in ), optional :: msg integer :: i call endwin () do i = 1 , size ( F % screen , 1 ) print '(100I1)' , F % screen ( i ,:) enddo if ( present ( P )) print * , P % why if ( present ( msg )) print * , msg print * , ' ' print * , 'Level:' , F % level Print * , 'Score:' , F % score print * , 'Number of Blocks:' , F % Nblock print * , 'Number of Lines Cleared:' , F % Ncleared print * , 'Block Sequence: ' , F % blockseq (: F % Nblock ) if ( F % debug ) then write ( F % udbg , * ) 'Block Sequence: ' , F % blockseq (: F % Nblock ) close ( F % udbg ) endif stop 'Goodbye from Tetran' end subroutine game_over end module blocks","tags":"","loc":"sourcefile/blocks.f90.html"},{"title":"rand_legacy.f90 – Tetran","text":"This file depends on sourcefile~~rand_legacy.f90~~EfferentGraph sourcefile~rand_legacy.f90 rand_legacy.f90 sourcefile~random.f90 random.f90 sourcefile~rand_legacy.f90->sourcefile~random.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules rand Source Code rand_legacy.f90 Source Code submodule ( random ) rand use , intrinsic :: iso_fortran_env , only : stderr => error_unit implicit none contains module procedure random_init ! NOTE: this subroutine is replaced by \"call random_init()\" in Fortran 2018 integer :: i , n , u , ios integer , allocatable :: seed (:) character ( * ), parameter :: randfn = '/dev/urandom' call random_seed ( size = n ) allocate ( seed ( n )) open ( newunit = u , file = randfn , access = \"stream\" , form = \"unformatted\" , action = \"read\" , status = \"old\" , iostat = ios ) if ( ios == 0 ) then read ( u , iostat = ios ) seed close ( u ) endif if ( ios /= 0 ) then write ( stderr , * ) 'falling back to internal random number generator' do i = 1 , n seed ( i ) = randint ( - 1073741823 , 1073741823 ) enddo endif call random_seed ( put = seed ) end procedure random_init end submodule rand","tags":"","loc":"sourcefile/rand_legacy.f90.html"},{"title":"rand.f90 – Tetran","text":"This file depends on sourcefile~~rand.f90~~EfferentGraph sourcefile~rand.f90 rand.f90 sourcefile~random.f90 random.f90 sourcefile~rand.f90->sourcefile~random.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules rand Source Code rand.f90 Source Code submodule ( random ) rand ! This is Fortran 2018 standard intrinsic :: random_init end submodule rand","tags":"","loc":"sourcefile/rand.f90.html"},{"title":"err.F90 – Tetran","text":"This file depends on sourcefile~~err.f90~~EfferentGraph sourcefile~err.f90 err.F90 sourcefile~cinter.f90 cinter.f90 sourcefile~err.f90->sourcefile~cinter.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~err.f90~~AfferentGraph sourcefile~err.f90 err.F90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~err.f90 sourcefile~keytest.f90 keytest.f90 sourcefile~keytest.f90->sourcefile~err.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules errs Source Code err.F90 Source Code module errs use , intrinsic :: iso_fortran_env , only : error_unit use cinter , only : endwin implicit none contains subroutine err ( msg ) character ( * ), intent ( in ) :: msg call endwin () write ( error_unit , * ) msg #if F08 error stop #else stop 1 #endif end subroutine err end module","tags":"","loc":"sourcefile/err.f90.html"},{"title":"fields.f90 – Tetran","text":"Files dependent on this one sourcefile~~fields.f90~~AfferentGraph sourcefile~fields.f90 fields.f90 sourcefile~ai.f90 ai.f90 sourcefile~ai.f90->sourcefile~fields.f90 sourcefile~shapes.f90 shapes.f90 sourcefile~ai.f90->sourcefile~shapes.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~fields.f90 sourcefile~keys.f90 keys.f90 sourcefile~main.f90->sourcefile~keys.f90 sourcefile~blocks.f90 blocks.f90 sourcefile~main.f90->sourcefile~blocks.f90 sourcefile~main.f90->sourcefile~shapes.f90 sourcefile~menu.f90 menu.f90 sourcefile~main.f90->sourcefile~menu.f90 sourcefile~keys.f90->sourcefile~fields.f90 sourcefile~keys.f90->sourcefile~ai.f90 sourcefile~keys.f90->sourcefile~blocks.f90 sourcefile~keys.f90->sourcefile~shapes.f90 sourcefile~test_shapes.f90 test_shapes.f90 sourcefile~test_shapes.f90->sourcefile~fields.f90 sourcefile~test_shapes.f90->sourcefile~shapes.f90 sourcefile~test_motion.f90 test_motion.f90 sourcefile~test_motion.f90->sourcefile~fields.f90 sourcefile~test_motion.f90->sourcefile~shapes.f90 sourcefile~blocks.f90->sourcefile~fields.f90 sourcefile~blocks.f90->sourcefile~shapes.f90 sourcefile~shapes.f90->sourcefile~fields.f90 sourcefile~menu.f90->sourcefile~fields.f90 sourcefile~menu.f90->sourcefile~blocks.f90 sourcefile~menu.f90->sourcefile~shapes.f90 sourcefile~test_menu.f90 test_menu.f90 sourcefile~test_menu.f90->sourcefile~menu.f90 sourcefile~randtest.f90 randtest.f90 sourcefile~randtest.f90->sourcefile~shapes.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules fields Source Code fields.f90 Source Code module fields use , intrinsic :: iso_c_binding , only : c_int implicit none private type , public :: Field ! Microseconds between each automatic downward move real :: move_time = 0.5 ! seconds integer ( c_int ) :: sleep_incr = 50000 !  keyboard polling and screen refresh interval (microseconds). ! 1e6 microsec: mushy controls. 1e5 microsec a little laggy. 5e4 about right. 1e4 microsec screen flicker. real :: difffact = 1. integer :: level = 1 real :: diffinc = 1.2 ! factor by which level jumps difficulty integer :: score = 0 integer :: Nblock = 0 integer :: Ncleared = 0 ! total number of lines cleared integer :: lines_per_level = 10 ! how many lines to clear to advance to next level integer :: bonus ( - 1 : 4 ) = [ - 100 , 0 , 40 , 100 , 300 , 1200 ] character ( 1 ) :: blockseq ( 10000 ) = \"\" ! record of blocks player experienced ! NOTE: uses eoshift to avoid indexing beyond array, discarding earliest turns integer :: toc , tic ! for each field's update time tracking integer :: H , W ! playfield height, width integer :: x0 ! master horizontal origin display coordinate for each playfield ! Playfield: 0 for blank integer , allocatable :: screen (:,:) logical :: debug = . false . integer :: udbg logical :: newhit = . false . logical :: cheat = . false . logical :: AI contains ! one per line for PGI, FLang procedure , public :: setup procedure , public :: levelup procedure , public :: clear_lines end type contains subroutine setup ( self , W , H , x0 , AI , difffact , debug ) class ( Field ), intent ( inout ) :: self integer , intent ( in ) :: H , W integer , intent ( in ), optional :: x0 logical , intent ( in ), optional :: AI real , intent ( in ), optional :: difffact logical , intent ( in ), optional :: debug self % H = H self % W = W self % x0 = 1 if ( present ( x0 )) self % x0 = x0 self % AI = . false . if ( present ( AI )) self % AI = AI if ( present ( difffact )) self % difffact = difffact if ( present ( debug )) self % debug = debug allocate ( self % screen ( self % H , self % W )) self % screen = 0 end subroutine setup subroutine levelup ( self ) class ( field ), intent ( inout ) :: self self % newhit = . false . self % level = self % level + 1 self % difffact = self % difffact * self % diffinc self % move_time = self % move_time / self % difffact end subroutine levelup subroutine clear_lines ( self ) class ( field ), intent ( inout ) :: self logical :: lines_to_clear ( self % H ) integer :: i , counter lines_to_clear = all ( self % screen == 1 , 2 ) ! mask of lines that need clearing counter = count ( lines_to_clear ) ! how many lines are cleared if ( counter == 0 ) return if ( self % cheat ) then counter = - 1 ! penalty self % cheat = . false . endif self % Ncleared = self % Ncleared + counter if ( self % debug ) write ( self % udbg , * ) lines_to_clear , counter self % score = self % score + self % bonus ( counter ) ! not concurrent since it could clear lines above shifted by other concurrent iterations ! i.e. in some cases, it would check an OK line that turns bad after clearing by another elemental iteration. ! also note non-adjacent lines can be cleared at once. do i = 1 , self % H if (. not . lines_to_clear ( i )) cycle self % newhit = . true . self % screen ( i ,:) = 0 ! wipe away cleared lines self % screen (: i , :) = cshift ( self % screen (: i , :), shift =- 1 , dim = 1 ) ! Bring everything down end do end subroutine clear_lines end module fields","tags":"","loc":"sourcefile/fields.f90.html"},{"title":"menu.f90 – Tetran","text":"This file depends on sourcefile~~menu.f90~~EfferentGraph sourcefile~menu.f90 menu.f90 sourcefile~random.f90 random.f90 sourcefile~menu.f90->sourcefile~random.f90 sourcefile~fields.f90 fields.f90 sourcefile~menu.f90->sourcefile~fields.f90 sourcefile~blocks.f90 blocks.f90 sourcefile~menu.f90->sourcefile~blocks.f90 sourcefile~shapes.f90 shapes.f90 sourcefile~menu.f90->sourcefile~shapes.f90 sourcefile~cinter.f90 cinter.f90 sourcefile~menu.f90->sourcefile~cinter.f90 sourcefile~blocks.f90->sourcefile~fields.f90 sourcefile~blocks.f90->sourcefile~shapes.f90 sourcefile~blocks.f90->sourcefile~cinter.f90 sourcefile~shapes.f90->sourcefile~random.f90 sourcefile~shapes.f90->sourcefile~fields.f90 sourcefile~rot90.f90 rot90.f90 sourcefile~shapes.f90->sourcefile~rot90.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~menu.f90~~AfferentGraph sourcefile~menu.f90 menu.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~menu.f90 sourcefile~test_menu.f90 test_menu.f90 sourcefile~test_menu.f90->sourcefile~menu.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules menu Source Code menu.f90 Source Code module menu use , intrinsic :: iso_c_binding , only : c_int , c_ptr use , intrinsic :: iso_fortran_env , only : stderr => error_unit use random , only : randint use cinter , only : mvaddch , usleep , refresh , clear , getch , noecho , cbreak , timeout use shapes , only : Piece use fields , only : field use blocks , only : draw_piece implicit none character ( 10 ) :: buf integer ( c_int ), parameter :: y0 = 5 , L = 10 , W = 80 , H = 60 contains subroutine title ( Fld ) class ( field ), intent ( in ), optional :: Fld type ( field ) :: F integer ( c_int ) :: x , i type ( piece ) :: T0 , E , T1 , R , A , N if ( present ( fld )) F = Fld call F % setup ( W = W , H = H ) x = 5 T0 = makeLetter ( F , y0 , x , \"t\" ) E = makeLetter ( F , y0 , x + ( L + 1 ), \"e\" ) T1 = makeLetter ( F , y0 , x + 2 * ( L + 1 ), \"t\" ) R = makeLetter ( F , y0 , x + 3 * ( L + 1 ), \"r\" ) A = makeLetter ( F , y0 , x + 4 * ( L + 1 ), \"a\" ) N = makeLetter ( F , y0 , x + 5 * ( L + 1 ), \"n\" ) call noecho () call cbreak () call timeout ( 0 ) call refresh () call usleep ( 250000 ) do i = 1 , size ( T0 % ch ) if ( getch () /= - 1 ) exit call clear () write ( buf , '(A6,I2)' ) 'Loop #' , i call dissolve ( T0 ) call dissolve ( E ) call dissolve ( T1 ) call dissolve ( R ) call dissolve ( A ) call dissolve ( N ) call refresh () call usleep ( 150000 ) enddo end subroutine title type ( piece ) function makeLetter ( F , y0 , x0 , letter ) result ( S ) type ( field ), intent ( in ) :: F integer ( c_int ), intent ( in ) :: y0 , x0 character , intent ( in ) :: letter call S % init ( F , letter , x = x0 , y = y0 ) call draw_piece ( S ) end function makeLetter recursive subroutine dissolve ( P ) class ( piece ), intent ( inout ) :: P integer :: i character ( 10 ) :: buf2 call P % dissolver () do i = 1 , randint ( 0 , P % H / ( L + 1 )) call P % move_down () if ( P % landed ) then write ( buf2 , '(A6,I2)' ) 'Move #' , i if ( any ( P % screen /= 0 )) error stop 'screen should be == 0' write ( stderr , * ) buf2 // buf // P % btype // ' letter was landed during dissolve ' // P % why endif enddo call draw_piece ( P ) end subroutine dissolve end module","tags":"","loc":"sourcefile/menu.f90.html"},{"title":"main.f90 – Tetran","text":"This file depends on sourcefile~~main.f90~~EfferentGraph sourcefile~main.f90 main.f90 sourcefile~err.f90 err.F90 sourcefile~main.f90->sourcefile~err.f90 sourcefile~random.f90 random.f90 sourcefile~main.f90->sourcefile~random.f90 sourcefile~fields.f90 fields.f90 sourcefile~main.f90->sourcefile~fields.f90 sourcefile~keys.f90 keys.f90 sourcefile~main.f90->sourcefile~keys.f90 sourcefile~blocks.f90 blocks.f90 sourcefile~main.f90->sourcefile~blocks.f90 sourcefile~shapes.f90 shapes.f90 sourcefile~main.f90->sourcefile~shapes.f90 sourcefile~cinter.f90 cinter.f90 sourcefile~main.f90->sourcefile~cinter.f90 sourcefile~menu.f90 menu.f90 sourcefile~main.f90->sourcefile~menu.f90 sourcefile~err.f90->sourcefile~cinter.f90 sourcefile~keys.f90->sourcefile~fields.f90 sourcefile~keys.f90->sourcefile~blocks.f90 sourcefile~keys.f90->sourcefile~shapes.f90 sourcefile~keys.f90->sourcefile~cinter.f90 sourcefile~ai.f90 ai.f90 sourcefile~keys.f90->sourcefile~ai.f90 sourcefile~blocks.f90->sourcefile~fields.f90 sourcefile~blocks.f90->sourcefile~shapes.f90 sourcefile~blocks.f90->sourcefile~cinter.f90 sourcefile~shapes.f90->sourcefile~random.f90 sourcefile~shapes.f90->sourcefile~fields.f90 sourcefile~rot90.f90 rot90.f90 sourcefile~shapes.f90->sourcefile~rot90.f90 sourcefile~menu.f90->sourcefile~random.f90 sourcefile~menu.f90->sourcefile~fields.f90 sourcefile~menu.f90->sourcefile~blocks.f90 sourcefile~menu.f90->sourcefile~shapes.f90 sourcefile~menu.f90->sourcefile~cinter.f90 sourcefile~ai.f90->sourcefile~fields.f90 sourcefile~ai.f90->sourcefile~shapes.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs tetran Source Code main.f90 Source Code program tetran use menu , only : title use cinter , only : initscr , noecho , mvprintw , mvaddch , & clear , timeout , usleep , cbreak , & maxH => LINES , maxW => COLS use errs , only : err use blocks , only : freeze , draw_piece use shapes , only : piece use fields , only : field use random , only : random_init , randint use keys , only : key_input use , intrinsic :: iso_c_binding , only : c_ptr implicit none type ( c_ptr ) :: stdscr integer :: trate ! elapsed time real :: difffact integer :: W , H , players , i integer :: x0 ( 2 ) logical :: debug , update = . false . logical :: isAI ( 2 ) = [. false ., . true .] type ( field ) :: F ( 2 ) type ( piece ) :: P ( 2 ), NP ( 2 ) !========================================== call random_init () call cmd_parse ( W = W , H = H , difffact = difffact , players = players , debug = debug ) !--- initialize Curses stdscr = initscr () ! too big -- FIXME generate new window for game if ( H + 3 > maxH ) call err ( 'playfield height too tall for terminal window' ) if ( W + 10 > maxW ) call err ( 'playfield width too wide for terminal window' ) x0 = [ 1 , W + 15 ] call noecho () call cbreak () call timeout ( 0 ) !--- show title screen call title () !--- begin game do i = 1 , players call F ( i )% setup ( W = W , H = H , x0 = x0 ( i ), AI = isAI ( i ), difffact = difffact , debug = debug ) !--- create first block call NP ( i )% init ( F ( i )) call P ( i )% spawn_block ( F ( i ), NP ( i )) call redraw ( F ( i ), P ( i ), NP ( i )) call system_clock ( count = F ( i )% tic , count_rate = trate ) enddo !--------- main loop do do i = 1 , players call main ( F ( i ), P ( i ), NP ( i )) enddo if ( update ) then call clear () do i = 1 , players call redraw ( F ( i ), P ( i ), NP ( i )) enddo update = . false . endif call usleep ( F ( 1 )% sleep_incr ) enddo contains subroutine main ( F , P , NP ) class ( field ) :: F type ( piece ) :: P , NP call key_input ( F , P , NP ) ! was a key pressed? call freeze ( F , P , NP ) if ( P % movereq ) update = . true . call system_clock ( count = F % toc ) !    if(debug) print *,F%toc-F%tic, F%toc, F%tic  ! in lower right corder of screen if ( ( F % toc - F % tic ) / real ( trate ) > F % move_time ) then !! time's up, move piece one step down. real(trate) is necessary for float time comparison! update = . true . call P % move_down () call freeze ( F , P , NP ) if ( F % newhit ) then if ( modulo ( F % Ncleared , F % lines_per_level ) == 0 ) call F % levelup () endif call system_clock ( count = F % tic ) endif end subroutine main subroutine redraw ( F , P , NP ) class ( field ), intent ( in ) :: F class ( piece ), intent ( in ) :: P , NP call draw_screen ( F ) ! Draw the falling block call draw_piece ( P ) ! Draw next block call draw_piece ( NP ) call draw_score ( F ) end subroutine redraw subroutine cmd_parse ( W , H , difffact , players , debug ) ! reads flag command line arguments integer , intent ( out ) :: W , H , players real , intent ( out ) :: difffact logical , intent ( out ) :: debug integer :: i , argc character ( * ), parameter :: logfn = 'tetran.log' character ( 32 ) :: arg character ( 8 ) :: date character ( 10 ) :: time ! --- default values W = randint ( 10 , 15 ) H = randint ( 15 , 20 ) difffact = 1. players = 1 debug = . false . ! --- process options argc = command_argument_count () do i = 1 , argc call get_command_argument ( i , arg ) select case ( arg ) case ( '-s' , '--size' ) ! set playfield size call get_command_argument ( i + 1 , arg ) read ( arg , '(I3)' ) W call get_command_argument ( i + 2 , arg ) read ( arg , '(I3)' ) H if ( H < 6 . or . W < 6 ) call err ( 'Height and width must each be at least 6' ) case ( '-d' , '--difficulty' ) call get_command_argument ( i + 1 , arg ) read ( arg , '(F4.1)' ) difffact if ( difffact <= 0 ) call err ( 'difficulty must be > 0' ) case ( '-p' , '--players' ) call get_command_argument ( i + 1 , arg ) read ( arg , '(I1)' ) players if ( players > 2 . or . players < 1 ) call err ( 'only 1 or 2 players' ) case ( '--debug' , '-v' , '--verbose' ) debug = . true . print * , 'debug enabled, writing to ' , logfn open ( newunit = F ( 1 )% udbg , file = logfn , action = 'Write' , & form = 'formatted' , status = 'unknown' , & position = 'append' ) call date_and_time ( date , time ) write ( F ( 1 )% udbg , * ) '--------------------------------------------' write ( F ( 1 )% udbg , * ) 'start: ' , date , 'T' , time write ( F ( 1 )% udbg , * ) 'Lines to clear                                 Counter' end select enddo end subroutine cmd_parse subroutine draw_screen ( F ) class ( field ), intent ( in ) :: F integer :: i , j ! not concurrent (and not where() ) since \"addch\" has memory of position do i = 1 , F % H do j = 1 , F % W select case ( F % screen ( i , j )) case ( 1 ) call mvaddch ( y = ( i - 1 ), x = F % x0 + ( j - 1 ) - 1 , ch = '@' ) ! frozen piece case ( 0 ) call mvaddch ( y = ( i - 1 ), x = F % x0 + ( j - 1 ) - 1 , ch = '.' ) ! background case default call err ( 'unknown screen state' ) end select end do end do end subroutine draw_screen subroutine draw_score ( F ) class ( field ), intent ( in ) :: F ! prints on line under bottom of playfield: !  score !  count of blocks played in this game character ( 16 ), save :: msg = \"\" ! this save variable is necessary to prevent garbage on screen write ( msg , \"(I10)\" ) F % score call mvprintw ( y = F % H , x = F % x0 + 0 , str = msg ) write ( msg , \"(I10)\" ) F % Nblock call mvprintw ( y = F % H + 1 , x = F % x0 + 0 , str = msg ) write ( msg , \"(I2)\" ) F % level call mvprintw ( y = F % H + 2 , x = F % x0 + 0 , str = msg ) write ( msg , \"(I4)\" ) F % Ncleared call mvprintw ( y = F % H + 2 , x = F % x0 + F % W - 4 , str = msg ) end subroutine draw_score end program","tags":"","loc":"sourcefile/main.f90.html"},{"title":"keytest.f90 – Tetran","text":"This file depends on sourcefile~~keytest.f90~~EfferentGraph sourcefile~keytest.f90 keytest.f90 sourcefile~cinter.f90 cinter.f90 sourcefile~keytest.f90->sourcefile~cinter.f90 sourcefile~err.f90 err.F90 sourcefile~keytest.f90->sourcefile~err.f90 sourcefile~err.f90->sourcefile~cinter.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs test_key Source Code keytest.f90 Source Code program test_key use , intrinsic :: iso_fortran_env , only : stdout => output_unit use , intrinsic :: iso_c_binding , only : c_int , c_ptr use cinter , only : initscr , getch , usleep use errs , only : endwin implicit none type ( c_ptr ) :: stdscr integer ( c_int ) :: ic logical :: lastEsc = . false . print * , 'press Esc twice to exit. Prints keys pressed and their code' call usleep ( 2000000 ) stdscr = initscr () do ic = getch () ! 4-byte integer, automatically prints character! ! read(stdin,*) ic !Nope write ( stdout , '(I4,A1,A1)' , advance = 'no' ) ic , ' ' , achar ( 13 ) flush ( stdout ) if ( lastEsc ) then if ( ic == 27 ) exit lastEsc = . false . else if ( ic == 27 ) lastEsc = . true . endif call usleep ( 200000 ) end do call endwin () end program","tags":"","loc":"sourcefile/keytest.f90.html"},{"title":"test_motion.f90 – Tetran","text":"This file depends on sourcefile~~test_motion.f90~~EfferentGraph sourcefile~test_motion.f90 test_motion.f90 sourcefile~shapes.f90 shapes.f90 sourcefile~test_motion.f90->sourcefile~shapes.f90 sourcefile~fields.f90 fields.f90 sourcefile~test_motion.f90->sourcefile~fields.f90 sourcefile~shapes.f90->sourcefile~fields.f90 sourcefile~rot90.f90 rot90.f90 sourcefile~shapes.f90->sourcefile~rot90.f90 sourcefile~random.f90 random.f90 sourcefile~shapes.f90->sourcefile~random.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs motiontest Source Code test_motion.f90 Source Code program motiontest ! -------- shape horiz. movement & rotation ! FIXME: Each shape should be tested. use , intrinsic :: iso_fortran_env , only : stderr => error_unit use shapes , only : piece use fields , only : field implicit none integer , parameter :: W = 10 , H = 10 logical :: failed = . false . failed = failed . or . initial ( \"I\" ) failed = failed . or . test_floor ( \"I\" ) failed = failed . or . left_wall ( \"I\" ) failed = failed . or . right_wall ( \"I\" ) failed = failed . or . block_hit ( \"I\" ) if ( failed ) then write ( stderr , * ) 'ERROR: Motion test' stop 1 endif print * , 'OK motion' contains logical function initial ( next ) result ( failed ) character , intent ( in ) :: next type ( field ) :: F type ( piece ) :: P failed = . true . print * , 'intiial position test...' call F % setup ( W = W , H = H ) call P % init ( F , btype = next , x = W / 2 ) if (. not .( P % y ==- 1 )) then write ( stderr , * ) next // ' bad initial Y position' return endif if ( P % landed ) then write ( stderr , * ) next // ' was initially landed' return endif call print_piece ( P ) failed = . false . end function initial logical function test_floor ( next ) result ( failed ) character , intent ( in ) :: next type ( field ) :: F type ( piece ) :: P integer :: y ! test positions failed = . true . print * , 'floor hit test...' call F % setup ( W = W , H = H ) call P % init ( F , next , W / 2 ) call P % move_down () ! y=0 y = P % y call P % move_down () ! y=1 if (. not .( y == P % y - 1 ) . and . P % y == 1 ) then write ( stderr , * ) next // ' failed to move down' , P % why return endif call P % move_down () ! y=2 call P % move_down () ! y=3 call P % move_down () ! y=4 call P % move_down () ! y=5 call P % move_down () ! y=6 call P % move_down () ! y=7 call P % move_down () ! y=8 call P % move_down () ! y=9 at bottom (allow sliding along floor before final freeze) if ( P % landed ) then write ( stderr , * ) next // ' floor before rotation) failing to slide along floor' , P % why return endif call P % move_down () ! y=10-1 landed (frozen) on bottom if (. not . P % landed ) then write ( stderr , * ) next // ' (floor before rotation)  failed to land.  Y=' , P % y return endif print * , 'OK:  ' , P % why y = P % y call P % move_down () ! y=10-1 frozen if (. not .( y == P % y )) then write ( stderr , * ) next // ' passed through floor!' , P % why return endif print * , 'OK:  ' , P % why y = P % y P % y = P % y - 1 ; P % landed = . false . ! y=9 manually unfreeze call P % rotate () if ( P % landed ) then write ( stderr , * ) next // ' (after rotation) early landing' , P % why return endif !call print_piece(P) call P % move_down () ! y=6 if ( P % landed ) then ! print *,'x,y', P%x, P%y write ( stderr , * ) next // ' (after rotation and movedown) failing to slide along floor' , P % why return endif call P % move_down () ! y=7 landed (frozen) on bottom if (. not . P % landed ) then write ( stderr , * ) next // ' (after rotation) failed to land' , P % why return endif y = P % y call P % move_down () ! y=7 pressing on bottom if (. not .( y == P % y )) then write ( stderr , * ) next // ' passed through floor!' , P % why return endif y = P % y failed = . false . end function test_floor logical function left_wall ( next ) result ( failed ) character , intent ( in ) :: next type ( field ) :: F type ( piece ) :: P integer :: x ! test positions failed = . true . print * , 'left wall test...' ! -- Left wall call F % setup ( W , H ) call P % init ( F , btype = next , x = W / 2 ) x = P % x call P % move_left () ! x=4 if ( P % x /= x - 1 ) then write ( stderr , * ) next // ' failed to move left' , P % why return endif call P % move_left () ! x=3 call P % move_left () ! x=2 call P % move_left () ! x=1 at left wall if ( P % x /= 1 ) then write ( stderr , * ) next // ' passing through left wall!' , P % why return endif x = P % x !call print_piece(line) ! -- rotate left wall call P % rotate () !call print_piece(line) call P % move_left () ! x=0 at left wall if ( P % x /= 0 ) then write ( stderr , * ) next // ' I move left after rotate' , P % why return endif call P % move_left () ! at left wall call P % move_left () ! pushing on left wall if ( P % x /= - 1 ) then write ( stderr , * ) next // ' I move left collision detection' , P % why return endif failed = . false . end function left_wall logical function right_wall ( next ) result ( failed ) character , intent ( in ) :: next type ( field ) :: F type ( piece ) :: P integer :: x ! test positions failed = . true . print * , 'right wall test...' call F % setup ( W , H ) call P % init ( F , next , W / 2 ) x = P % x !call print_piece(line) call P % move_right () ! x=5 if ( P % x /= x + 1 ) then write ( stderr , * ) next // ' failed to move right' , P % why return endif call P % move_right () ! x=6 call P % move_right () ! x=6 call P % move_right () ! x=7 at right wall call P % move_right () ! x=7 pushing on right wall if ( P % x /= W - 3 ) then write ( stderr , * ) next // ' (before rotate) I move right collision detection' , P % why return endif call P % rotate () call P % move_right () ! at right wall call P % move_right () ! pushing on right wall if ( P % x /= W - 2 ) then write ( stderr , * ) next // ' (after rotate) I move right collision detection' , P % why return endif failed = . false . end function right_wall logical function block_hit ( next ) result ( failed ) character , intent ( in ) :: next type ( field ) :: F type ( piece ) :: P integer :: y ! test positions failed = . true . print * , 'block hit test...' call F % setup ( W , H ) !-- single pixel object in center bottom of floor F % screen ( H - 2 , W / 2 ) = 1 !call print_block(F%screen) call P % init ( F , btype = next , x = W / 2 ) call P % rotate () !call print_piece(P) call P % move_down () ! y=0 y = P % y call P % move_down () ! y=1 if (. not .( y == P % y - 1 ) . and . P % y == 1 ) then write ( stderr , * ) next // ' (obj) failure to move down' , P % why return endif call P % move_down () ! y=2 call P % move_down () ! y=3 call P % move_down () ! y=4 call P % move_down () ! y=5 next to bottom (allow sliding along floor before final freeze) if ( P % landed ) then write ( stderr , * ) 'x,y' , P % x , P % y write ( stderr , * ) next // ' (obj before rotation) failing to slide along object' , P % why return endif call P % move_down () ! y=5 landed (frozen) on bottom call P % move_down () ! y=5 landed (frozen) on bottom call P % move_down () ! y=5 landed (frozen) on bottom if (. not . P % landed ) then write ( stderr , * ) next // ' (obj before rotation)  failed to land' , P % why return endif y = P % y call P % move_down () ! y=5 pressing on bottom if (. not .( y == P % y )) then write ( stderr , * ) next // ' obj passed through floor!' , P % why return endif y = P % y failed = . false . end function block_hit subroutine print_piece ( P ) class ( piece ), intent ( in ) :: P call print_block ( P % values ) end subroutine print_piece subroutine print_block ( B ) integer , intent ( in ) :: B (:,:) integer :: i do i = 1 , size ( B , 1 ) print '(8I1)' , B ( i ,:) enddo end subroutine print_block end program","tags":"","loc":"sourcefile/test_motion.f90.html"},{"title":"test_menu.f90 – Tetran","text":"This file depends on sourcefile~~test_menu.f90~~EfferentGraph sourcefile~test_menu.f90 test_menu.f90 sourcefile~cinter.f90 cinter.f90 sourcefile~test_menu.f90->sourcefile~cinter.f90 sourcefile~menu.f90 menu.f90 sourcefile~test_menu.f90->sourcefile~menu.f90 sourcefile~menu.f90->sourcefile~cinter.f90 sourcefile~shapes.f90 shapes.f90 sourcefile~menu.f90->sourcefile~shapes.f90 sourcefile~fields.f90 fields.f90 sourcefile~menu.f90->sourcefile~fields.f90 sourcefile~blocks.f90 blocks.f90 sourcefile~menu.f90->sourcefile~blocks.f90 sourcefile~random.f90 random.f90 sourcefile~menu.f90->sourcefile~random.f90 sourcefile~shapes.f90->sourcefile~fields.f90 sourcefile~shapes.f90->sourcefile~random.f90 sourcefile~rot90.f90 rot90.f90 sourcefile~shapes.f90->sourcefile~rot90.f90 sourcefile~blocks.f90->sourcefile~cinter.f90 sourcefile~blocks.f90->sourcefile~shapes.f90 sourcefile~blocks.f90->sourcefile~fields.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs test_menu Source Code test_menu.f90 Source Code program test_menu use , intrinsic :: iso_c_binding , only : c_ptr use cinter , only : initscr , endwin use menu , only : title implicit none type ( c_ptr ) :: stdscr stdscr = initscr () call title () call endwin () end program","tags":"","loc":"sourcefile/test_menu.f90.html"},{"title":"randtest.f90 – Tetran","text":"This file depends on sourcefile~~randtest.f90~~EfferentGraph sourcefile~randtest.f90 randtest.f90 sourcefile~shapes.f90 shapes.f90 sourcefile~randtest.f90->sourcefile~shapes.f90 sourcefile~random.f90 random.f90 sourcefile~randtest.f90->sourcefile~random.f90 sourcefile~shapes.f90->sourcefile~random.f90 sourcefile~fields.f90 fields.f90 sourcefile~shapes.f90->sourcefile~fields.f90 sourcefile~rot90.f90 rot90.f90 sourcefile~shapes.f90->sourcefile~rot90.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs randblock Source Code randtest.f90 Source Code program randblock ! confirms random distribution of block types use , intrinsic :: iso_fortran_env , only : dp => real64 use shapes , only : gen_type use random , only : random_init , randint , std , mean implicit none character ( * ), parameter :: types = 'ITLJSZOD' integer , parameter :: Ntypes = len ( types ) real , parameter :: rtol = 0.01 real :: ideal character , allocatable :: b (:) real , allocatable :: e (:) integer , allocatable :: f (:), g (:) integer :: i , n , c ( Ntypes ), u character ( 16 ) :: buf call random_init () do i = 1 , 10 print * , randint ( 1 , 8 ) enddo N = 1000000 call get_command_argument ( 1 , buf , status = i ) if ( i == 0 ) read ( buf , * ) N ideal = N / Ntypes allocate ( b ( N ), e ( N ), f ( N ), g ( N )) do i = 1 , N b ( i ) = gen_type () enddo ! results print * , new_line ( '' ), 'ideal count:' , int ( ideal ), new_line ( '' ) print '(A5,A16,A10)' , 'Block' , 'Count' , 'Error %' print '(A5,A16,A10)' , '-----' , '-----' , '-------' do i = 1 , Ntypes !do concurrent (i=1:Ntypes) ! even with ifort -parallel, still single core (with print commented) c ( i ) = count ( b == types ( i : i )) e ( i ) = abs ( c ( i ) - ideal ) / ideal print '(A5,I16,F10.3)' , types ( i : i ), c ( i ), e ( i ) * 100 enddo ! randomness simple check -- sufficiently uniformly random if ( any ( e > rtol )) then error stop 'non-uniform randomness posssible. Is N > 1000000?' endif ! ----------- do i = 1 , N f ( i ) = randint ( - 1073741823 , 1073741823 ) enddo print * , new_line ( ' ' ), 'huge(int)' , huge ( 0 ), 'huge(real)' , huge ( 0. ) print * , 'expected std, mean' , real ( huge ( 0 ), dp ) / sqrt ( 1 2._dp ), 0. print * , 'std, mean randint()' , std ( f ), mean ( f ) print * , 'a few values' , f (: 6 ) print * , new_line ( ' ' ), '/dev/urandom a few values...' open ( newunit = u , file = '/dev/urandom' , access = \"stream\" , form = \"unformatted\" , action = \"read\" , status = \"old\" ) read ( u ) G close ( u ) print * , 'std, mean /dev/urandom' , std ( g ), mean ( g ) end program","tags":"","loc":"sourcefile/randtest.f90.html"},{"title":"test_shapes.f90 – Tetran","text":"This file depends on sourcefile~~test_shapes.f90~~EfferentGraph sourcefile~test_shapes.f90 test_shapes.f90 sourcefile~shapes.f90 shapes.f90 sourcefile~test_shapes.f90->sourcefile~shapes.f90 sourcefile~fields.f90 fields.f90 sourcefile~test_shapes.f90->sourcefile~fields.f90 sourcefile~random.f90 random.f90 sourcefile~test_shapes.f90->sourcefile~random.f90 sourcefile~shapes.f90->sourcefile~fields.f90 sourcefile~shapes.f90->sourcefile~random.f90 sourcefile~rot90.f90 rot90.f90 sourcefile~shapes.f90->sourcefile~rot90.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs testshapes Source Code test_shapes.f90 Source Code program testshapes use , intrinsic :: iso_fortran_env , only : stderr => error_unit use shapes , only : piece use fields , only : field use random , only : random_init implicit none type ( field ) :: F type ( piece ) :: S , line , tee , ell , jay , ess , zee , oh integer , parameter :: Ny = 4 , Nx = 4 , W = 6 , H = 10 integer , parameter :: Ntest = 100 ! arbitrary integer :: i integer :: xarr ( Ntest ) ! test for randomness etc. call random_init () call F % setup ( W = W , H = H ) ! must generate playfield before any pieces, or they will die when they realize they're outside a playfield !print '(6I1)',transpose(F%screen) print * , 'H ' , F % H , 'W ' , F % W !------- shape essentials print * , 'initial x-position test....' do i = 1 , Ntest call S % init ( F , \"I\" ) xarr ( i ) = S % x enddo call check_x ( xarr ) print * , 'random shape types test...' if ( all ( xarr == xarr ( 1 ))) call err ( 'non-random shape initial x-position' ) print * , 'initial y position test...' if (. not . S % y ==- 1 ) then write ( stderr , '(A,I3)' ) 'initial y position ' , S % y call err ( 'shape initial y-position not at top of playfield (-1)' ) endif print * , 'test I' call line % init ( F , \"I\" ) if (. not . line % btype == 'I' ) call err ( 'I type' ) if (. not . allocated ( line % values )) call err ( 'I init' ) if (. not . all ( shape ( line % values ) == [ Ny , Nx ])) call err ( 'I shape' ) print * , 'test T' call tee % init ( F , \"T\" ) if (. not . tee % btype == 'T' ) call err ( 'T type' ) if (. not . allocated ( tee % values )) call err ( 'T init' ) if (. not . all ( shape ( tee % values ) == [ Ny - 1 , Nx - 1 ])) call err ( 'T shape' ) print * , 'test L' call ell % init ( F , \"L\" ) if (. not . ell % btype == 'L' ) call err ( 'L type' ) if (. not . allocated ( ell % values )) call err ( 'L init' ) if (. not . all ( shape ( ell % values ) == [ Ny - 1 , Nx - 1 ])) call err ( 'L shape' ) print * , 'test J' call jay % init ( F , \"J\" ) if (. not . jay % btype == 'J' ) call err ( 'J type' ) if (. not . allocated ( jay % values )) call err ( 'J init' ) if (. not . all ( shape ( jay % values ) == [ Ny - 1 , Nx - 1 ])) call err ( 'J shape' ) print * , 'test S' call ess % init ( F , \"S\" ) if (. not . ess % btype == 'S' ) call err ( 'S type' ) if (. not . allocated ( ess % values )) call err ( 'S init' ) if (. not . all ( shape ( ess % values ) == [ Ny - 1 , Nx - 1 ])) call err ( 'S shape' ) print * , 'test Z' call zee % init ( F , \"Z\" ) if (. not . zee % btype == 'Z' ) call err ( 'Z type' ) if (. not . allocated ( zee % values )) call err ( 'Z init' ) if (. not . all ( shape ( zee % values ) == [ Ny - 1 , Nx - 1 ])) call err ( 'Z shape' ) print * , 'test O' call oh % init ( F , \"O\" ) if (. not . oh % btype == 'O' ) call err ( 'O type' ) if (. not . allocated ( oh % values )) call err ( 'O init' ) if (. not . all ( shape ( oh % values ) == [ Ny - 2 , Nx - 2 ])) call err ( 'O shape' ) print * , 'OK shapes' contains subroutine check_x ( x ) integer , intent ( in ) :: x (:) if (. not .( minval ( x ) >= 1 . and . maxval ( x ) <= W - Nx )) then write ( stderr , '(A,I3,A,I3)' ) 'min(x) ' , minval ( x ), ' max(x) ' , maxval ( x ) call err ( 'shape initial X position out of playfield' ) endif if ( all ( x == x ( 1 ))) then write ( stderr , '(A,I1)' ) 'all X are identically ' , x ( 1 ) call err ( 'non random x' ) endif end subroutine check_x subroutine err ( msg ) character ( * ), intent ( in ) :: msg write ( stderr , * ) msg stop - 1 end subroutine err end program","tags":"","loc":"sourcefile/test_shapes.f90.html"},{"title":"Piece – Tetran ","text":"type, public, extends( Field ) :: Piece Inherits type~~piece~~InheritsGraph type~piece Piece type~field Field type~piece->type~field Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables move_time sleep_incr difffact level diffinc score Nblock Ncleared lines_per_level bonus blockseq toc tic H W x0 screen debug udbg newhit cheat AI btype why ch Nx Ny x y values landed movereq Type-Bound Procedures setup levelup clear_lines init init_block check_collision move_right move_left rotate move_down dissolver spawn_block vertflip horizflip randomx tell_why hit_horiz hit_floor hit_block Components Type Visibility Attributes Name Initial real, public :: move_time = 0.5 integer(kind=c_int), public :: sleep_incr = 50000 real, public :: difffact = 1. integer, public :: level = 1 real, public :: diffinc = 1.2 integer, public :: score = 0 integer, public :: Nblock = 0 integer, public :: Ncleared = 0 integer, public :: lines_per_level = 10 integer, public :: bonus (-1:4) = [-100, 0, 40, 100, 300, 1200] character(len=1), public :: blockseq (10000) = \"\" integer, public :: toc integer, public :: tic integer, public :: H integer, public :: W integer, public :: x0 integer, public, allocatable :: screen (:,:) logical, public :: debug = .false. integer, public :: udbg logical, public :: newhit = .false. logical, public :: cheat = .false. logical, public :: AI character, public :: btype character(len=80), public :: why character, public :: ch (12) integer, public :: Nx integer, public :: Ny integer, public :: x integer, public :: y integer, public, allocatable :: values (:,:) logical, public :: landed logical, public :: movereq Type-Bound Procedures procedure, public :: setup private subroutine setup (self, W, H, x0, AI, difffact, debug) Arguments Type Intent Optional Attributes Name class( Field ), intent(inout) :: self integer, intent(in) :: W integer, intent(in) :: H integer, intent(in), optional :: x0 logical, intent(in), optional :: AI real, intent(in), optional :: difffact logical, intent(in), optional :: debug procedure, public :: levelup private subroutine levelup (self) Arguments Type Intent Optional Attributes Name class( Field ), intent(inout) :: self procedure, public :: clear_lines private subroutine clear_lines (self) Arguments Type Intent Optional Attributes Name class( Field ), intent(inout) :: self procedure, public :: init => init_block private subroutine init_block (self, F, btype, x, y) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self class( Field ), intent(in) :: F character, intent(in), optional :: btype integer, intent(in), optional :: x integer, intent(in), optional :: y procedure, private :: init_block private subroutine init_block (self, F, btype, x, y) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self class( Field ), intent(in) :: F character, intent(in), optional :: btype integer, intent(in), optional :: x integer, intent(in), optional :: y procedure, public :: check_collision private function check_collision (self) result(collided) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self Return Value logical procedure, public :: move_right private subroutine move_right (self, slam) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self logical, intent(in), optional :: slam procedure, public :: move_left private subroutine move_left (self, slam) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self logical, intent(in), optional :: slam procedure, public :: rotate private subroutine rotate (self) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self procedure, public :: move_down private recursive subroutine move_down (self, slam) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self logical, intent(in), optional :: slam procedure, public :: dissolver private subroutine dissolver (self) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self procedure, public :: spawn_block private subroutine spawn_block (self, F, NP) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self class( Field ), intent(inout) :: F class( Piece ), intent(inout), optional :: NP procedure, public :: vertflip private subroutine vertflip (self) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self procedure, public :: horizflip private subroutine horizflip (self) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self procedure, private :: randomx private function randomx (self) Arguments Type Intent Optional Attributes Name class( Piece ), intent(in) :: self Return Value integer procedure, private :: tell_why private subroutine tell_why (self, msg) Arguments Type Intent Optional Attributes Name class( Piece ), intent(in) :: self character(len=*), intent(in), optional :: msg procedure, private :: hit_horiz private function hit_horiz (self) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self Return Value logical procedure, private :: hit_floor private function hit_floor (self) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self Return Value logical procedure, private :: hit_block private function hit_block (self) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self Return Value logical","tags":"","loc":"type/piece.html"},{"title":"Field – Tetran ","text":"type, public :: Field Inherited by type~~field~~InheritedByGraph type~field Field type~piece Piece type~piece->type~field Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables move_time sleep_incr difffact level diffinc score Nblock Ncleared lines_per_level bonus blockseq toc tic H W x0 screen debug udbg newhit cheat AI Type-Bound Procedures setup levelup clear_lines Components Type Visibility Attributes Name Initial real, public :: move_time = 0.5 integer(kind=c_int), public :: sleep_incr = 50000 real, public :: difffact = 1. integer, public :: level = 1 real, public :: diffinc = 1.2 integer, public :: score = 0 integer, public :: Nblock = 0 integer, public :: Ncleared = 0 integer, public :: lines_per_level = 10 integer, public :: bonus (-1:4) = [-100, 0, 40, 100, 300, 1200] character(len=1), public :: blockseq (10000) = \"\" integer, public :: toc integer, public :: tic integer, public :: H integer, public :: W integer, public :: x0 integer, public, allocatable :: screen (:,:) logical, public :: debug = .false. integer, public :: udbg logical, public :: newhit = .false. logical, public :: cheat = .false. logical, public :: AI Type-Bound Procedures procedure, public :: setup private subroutine setup (self, W, H, x0, AI, difffact, debug) Arguments Type Intent Optional Attributes Name class( Field ), intent(inout) :: self integer, intent(in) :: W integer, intent(in) :: H integer, intent(in), optional :: x0 logical, intent(in), optional :: AI real, intent(in), optional :: difffact logical, intent(in), optional :: debug procedure, public :: levelup private subroutine levelup (self) Arguments Type Intent Optional Attributes Name class( Field ), intent(inout) :: self procedure, public :: clear_lines private subroutine clear_lines (self) Arguments Type Intent Optional Attributes Name class( Field ), intent(inout) :: self","tags":"","loc":"type/field.html"},{"title":"randint – Tetran","text":"public impure elemental function randint(lo, hi) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lo integer, intent(in) :: hi Return Value integer Called by proc~~randint~~CalledByGraph proc~randint randint proc~cmd_parse cmd_parse proc~cmd_parse->proc~randint proc~randomx randomx proc~randomx->proc~randint proc~gen_type gen_type proc~gen_type->proc~randint proc~dissolve dissolve proc~dissolve->proc~randint proc~random_init random_init proc~random_init->proc~randint proc~random_init~2 random_init proc~random_init~2->proc~randint program~randblock randblock program~randblock->proc~randint program~randblock->proc~gen_type program~randblock->proc~random_init program~tetran tetran program~tetran->proc~cmd_parse program~tetran->proc~random_init proc~title title program~tetran->proc~title proc~title->proc~dissolve program~testshapes testshapes program~testshapes->proc~random_init proc~init_block init_block proc~init_block->proc~gen_type program~test_menu test_menu program~test_menu->proc~title Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/randint.html"},{"title":"std_real – Tetran","text":"public pure function std_real(A) result(std) Arguments Type Intent Optional Attributes Name real, intent(in) :: A (:) Return Value real Calls proc~~std_real~~CallsGraph proc~std_real std_real interface~mean mean proc~std_real->interface~mean proc~mean_real mean_real interface~mean->proc~mean_real proc~mean_int mean_int interface~mean->proc~mean_int Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~std_real~~CalledByGraph proc~std_real std_real interface~std std interface~std->proc~std_real program~randblock randblock program~randblock->interface~std Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/std_real.html"},{"title":"std_int – Tetran","text":"public pure function std_int(A) result(std) Arguments Type Intent Optional Attributes Name integer, intent(in) :: A (:) Return Value real Calls proc~~std_int~~CallsGraph proc~std_int std_int interface~mean mean proc~std_int->interface~mean proc~mean_real mean_real interface~mean->proc~mean_real proc~mean_int mean_int interface~mean->proc~mean_int Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~std_int~~CalledByGraph proc~std_int std_int interface~std std interface~std->proc~std_int program~randblock randblock program~randblock->interface~std Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/std_int.html"},{"title":"mean_real – Tetran","text":"public pure function mean_real(A) result(mean) Arguments Type Intent Optional Attributes Name real, intent(in) :: A (:) Return Value real Called by proc~~mean_real~~CalledByGraph proc~mean_real mean_real interface~mean mean interface~mean->proc~mean_real proc~std_real std_real proc~std_real->interface~mean proc~std_int std_int proc~std_int->interface~mean program~randblock randblock program~randblock->interface~mean interface~std std program~randblock->interface~std interface~std->proc~std_real interface~std->proc~std_int Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/mean_real.html"},{"title":"mean_int – Tetran","text":"public pure function mean_int(A) result(mean) Arguments Type Intent Optional Attributes Name integer, intent(in) :: A (:) Return Value real Called by proc~~mean_int~~CalledByGraph proc~mean_int mean_int interface~mean mean interface~mean->proc~mean_int proc~std_real std_real proc~std_real->interface~mean proc~std_int std_int proc~std_int->interface~mean program~randblock randblock program~randblock->interface~mean interface~std std program~randblock->interface~std interface~std->proc~std_real interface~std->proc~std_int Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/mean_int.html"},{"title":"random_init – Tetran","text":"public subroutine random_init() Arguments None Calls proc~~random_init~~CallsGraph proc~random_init random_init proc~randint randint proc~random_init->proc~randint Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~random_init~~CalledByGraph proc~random_init random_init program~tetran tetran program~tetran->proc~random_init program~testshapes testshapes program~testshapes->proc~random_init program~randblock randblock program~randblock->proc~random_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/random_init.html"},{"title":"std – Tetran","text":"public interface std Calls interface~~std~~CallsGraph interface~std std proc~std_int std_int interface~std->proc~std_int proc~std_real std_real interface~std->proc~std_real interface~mean mean proc~std_int->interface~mean proc~std_real->interface~mean proc~mean_real mean_real interface~mean->proc~mean_real proc~mean_int mean_int interface~mean->proc~mean_int Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~std~~CalledByGraph interface~std std program~randblock randblock program~randblock->interface~std Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures std_int std_real Module Procedures public pure function std_int (A) result(std) Arguments Type Intent Optional Attributes Name integer, intent(in) :: A (:) Return Value real public pure function std_real (A) result(std) Arguments Type Intent Optional Attributes Name real, intent(in) :: A (:) Return Value real","tags":"","loc":"interface/std.html"},{"title":"mean – Tetran","text":"public interface mean Calls interface~~mean~~CallsGraph interface~mean mean proc~mean_real mean_real interface~mean->proc~mean_real proc~mean_int mean_int interface~mean->proc~mean_int Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~mean~~CalledByGraph interface~mean mean proc~std_real std_real proc~std_real->interface~mean proc~std_int std_int proc~std_int->interface~mean program~randblock randblock program~randblock->interface~mean interface~std std program~randblock->interface~std interface~std->proc~std_real interface~std->proc~std_int Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures mean_int mean_real Module Procedures public pure function mean_int (A) result(mean) Arguments Type Intent Optional Attributes Name integer, intent(in) :: A (:) Return Value real public pure function mean_real (A) result(mean) Arguments Type Intent Optional Attributes Name real, intent(in) :: A (:) Return Value real","tags":"","loc":"interface/mean.html"},{"title":"project_down – Tetran","text":"public function project_down(F, P) result(y) Arguments Type Intent Optional Attributes Name class( Field ), intent(in) :: F class( Piece ), intent(in) :: P Return Value integer Called by proc~~project_down~~CalledByGraph proc~project_down project_down proc~height height proc~height->proc~project_down proc~ai_input AI_input proc~ai_input->proc~project_down proc~seek_deep seek_deep proc~ai_input->proc~seek_deep proc~seek_deep->proc~height proc~key_input key_input proc~key_input->proc~ai_input proc~main main proc~main->proc~key_input Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/project_down.html"},{"title":"height – Tetran","text":"public function height(F, P) Arguments Type Intent Optional Attributes Name class( Field ), intent(in) :: F class( Piece ), intent(in) :: P Return Value integer Calls proc~~height~~CallsGraph proc~height height proc~project_down project_down proc~height->proc~project_down Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~height~~CalledByGraph proc~height height proc~seek_deep seek_deep proc~seek_deep->proc~height proc~ai_input AI_input proc~ai_input->proc~seek_deep proc~key_input key_input proc~key_input->proc~ai_input proc~main main proc~main->proc~key_input Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/height.html"},{"title":"diff – Tetran","text":"public pure function diff(A) Arguments Type Intent Optional Attributes Name integer, intent(in) :: A (:) Return Value integer Contents None","tags":"","loc":"proc/diff.html"},{"title":"AI_input – Tetran","text":"public subroutine AI_input(F, P) Arguments Type Intent Optional Attributes Name class( Field ), intent(in) :: F class( Piece ), intent(inout) :: P Calls proc~~ai_input~~CallsGraph proc~ai_input AI_input proc~project_down project_down proc~ai_input->proc~project_down proc~seek_deep seek_deep proc~ai_input->proc~seek_deep proc~down_random down_random proc~ai_input->proc~down_random proc~move_random move_random proc~seek_deep->proc~move_random proc~height height proc~seek_deep->proc~height proc~height->proc~project_down Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~ai_input~~CalledByGraph proc~ai_input AI_input proc~key_input key_input proc~key_input->proc~ai_input proc~main main proc~main->proc~key_input Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ai_input.html"},{"title":"seek_deep – Tetran","text":"public subroutine seek_deep(F, P) Arguments Type Intent Optional Attributes Name class( Field ), intent(in) :: F class( Piece ), intent(inout) :: P Calls proc~~seek_deep~~CallsGraph proc~seek_deep seek_deep proc~move_random move_random proc~seek_deep->proc~move_random proc~height height proc~seek_deep->proc~height proc~project_down project_down proc~height->proc~project_down Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~seek_deep~~CalledByGraph proc~seek_deep seek_deep proc~ai_input AI_input proc~ai_input->proc~seek_deep proc~key_input key_input proc~key_input->proc~ai_input proc~main main proc~main->proc~key_input Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/seek_deep.html"},{"title":"down_random – Tetran","text":"public subroutine down_random(P) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: P Called by proc~~down_random~~CalledByGraph proc~down_random down_random proc~ai_input AI_input proc~ai_input->proc~down_random proc~key_input key_input proc~key_input->proc~ai_input proc~main main proc~main->proc~key_input Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/down_random.html"},{"title":"move_random – Tetran","text":"public subroutine move_random(P) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: P Called by proc~~move_random~~CalledByGraph proc~move_random move_random proc~seek_deep seek_deep proc~seek_deep->proc~move_random proc~ai_input AI_input proc~ai_input->proc~seek_deep proc~key_input key_input proc~key_input->proc~ai_input proc~main main proc~main->proc~key_input Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/move_random.html"},{"title":"rot90 – Tetran","text":"public function rot90(A, k) Arguments Type Intent Optional Attributes Name integer, intent(in) :: A (:,:) integer, intent(in), optional :: k Return Value integer Calls proc~~rot90~~CallsGraph proc~rot90 rot90 proc~flip flip proc~rot90->proc~flip Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rot90~~CalledByGraph proc~rot90 rot90 proc~rotate rotate proc~rotate->proc~rot90 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rot90.html"},{"title":"flip – Tetran","text":"public function flip(A, d) Arguments Type Intent Optional Attributes Name integer, intent(in) :: A (:,:) integer, intent(in) :: d Return Value integer Called by proc~~flip~~CalledByGraph proc~flip flip proc~fliplr fliplr proc~fliplr->proc~flip proc~rot90 rot90 proc~rot90->proc~flip proc~flipud flipud proc~flipud->proc~flip proc~horizflip horizflip proc~horizflip->proc~fliplr proc~rotate rotate proc~rotate->proc~rot90 proc~vertflip vertflip proc~vertflip->proc~flipud Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/flip.html"},{"title":"flipud – Tetran","text":"public function flipud(A) Arguments Type Intent Optional Attributes Name integer, intent(in) :: A (:,:) Return Value integer Calls proc~~flipud~~CallsGraph proc~flipud flipud proc~flip flip proc~flipud->proc~flip Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~flipud~~CalledByGraph proc~flipud flipud proc~vertflip vertflip proc~vertflip->proc~flipud Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/flipud.html"},{"title":"fliplr – Tetran","text":"public function fliplr(A) Arguments Type Intent Optional Attributes Name integer, intent(in) :: A (:,:) Return Value integer Calls proc~~fliplr~~CallsGraph proc~fliplr fliplr proc~flip flip proc~fliplr->proc~flip Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~fliplr~~CalledByGraph proc~fliplr fliplr proc~horizflip horizflip proc~horizflip->proc~fliplr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/fliplr.html"},{"title":"gen_type – Tetran","text":"public function gen_type() result(next) Arguments None Return Value character Calls proc~~gen_type~~CallsGraph proc~gen_type gen_type proc~randint randint proc~gen_type->proc~randint Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~gen_type~~CalledByGraph proc~gen_type gen_type proc~init_block init_block proc~init_block->proc~gen_type program~randblock randblock program~randblock->proc~gen_type Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/gen_type.html"},{"title":"check_collision – Tetran","text":"private function check_collision(self) result(collided) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self Return Value logical Contents None","tags":"","loc":"proc/check_collision.html"},{"title":"hit_floor – Tetran","text":"private function hit_floor(self) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self Return Value logical Contents None","tags":"","loc":"proc/hit_floor.html"},{"title":"hit_horiz – Tetran","text":"private function hit_horiz(self) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self Return Value logical Contents None","tags":"","loc":"proc/hit_horiz.html"},{"title":"hit_block – Tetran","text":"private function hit_block(self) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self Return Value logical Contents None","tags":"","loc":"proc/hit_block.html"},{"title":"randomx – Tetran","text":"private function randomx(self) Arguments Type Intent Optional Attributes Name class( Piece ), intent(in) :: self Return Value integer Calls proc~~randomx~~CallsGraph proc~randomx randomx proc~randint randint proc~randomx->proc~randint Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/randomx.html"},{"title":"init_block – Tetran","text":"private subroutine init_block(self, F, btype, x, y) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self class( Field ), intent(in) :: F character, intent(in), optional :: btype integer, intent(in), optional :: x integer, intent(in), optional :: y Calls proc~~init_block~~CallsGraph proc~init_block init_block proc~gen_type gen_type proc~init_block->proc~gen_type proc~randint randint proc~gen_type->proc~randint Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/init_block.html"},{"title":"spawn_block – Tetran","text":"private subroutine spawn_block(self, F, NP) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self class( Field ), intent(inout) :: F class( Piece ), intent(inout), optional :: NP Contents None","tags":"","loc":"proc/spawn_block.html"},{"title":"dissolver – Tetran","text":"private subroutine dissolver(self) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self Contents None","tags":"","loc":"proc/dissolver.html"},{"title":"move_left – Tetran","text":"private subroutine move_left(self, slam) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self logical, intent(in), optional :: slam Contents None","tags":"","loc":"proc/move_left.html"},{"title":"move_right – Tetran","text":"private subroutine move_right(self, slam) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self logical, intent(in), optional :: slam Contents None","tags":"","loc":"proc/move_right.html"},{"title":"move_down – Tetran","text":"private recursive subroutine move_down(self, slam) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self logical, intent(in), optional :: slam Contents None","tags":"","loc":"proc/move_down.html"},{"title":"rotate – Tetran","text":"private subroutine rotate(self) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self Calls proc~~rotate~~CallsGraph proc~rotate rotate proc~rot90 rot90 proc~rotate->proc~rot90 proc~flip flip proc~rot90->proc~flip Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rotate.html"},{"title":"vertflip – Tetran","text":"private subroutine vertflip(self) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self Calls proc~~vertflip~~CallsGraph proc~vertflip vertflip proc~flipud flipud proc~vertflip->proc~flipud proc~flip flip proc~flipud->proc~flip Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/vertflip.html"},{"title":"horizflip – Tetran","text":"private subroutine horizflip(self) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self Calls proc~~horizflip~~CallsGraph proc~horizflip horizflip proc~fliplr fliplr proc~horizflip->proc~fliplr proc~flip flip proc~fliplr->proc~flip Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/horizflip.html"},{"title":"tell_why – Tetran","text":"private subroutine tell_why(self, msg) Arguments Type Intent Optional Attributes Name class( Piece ), intent(in) :: self character(len=*), intent(in), optional :: msg Contents None","tags":"","loc":"proc/tell_why.html"},{"title":"initscr – Tetran","text":"public function initscr() result(stdscr__OUT) Arguments None Return Value type(C_PTR) Calls proc~~initscr~~CallsGraph proc~initscr initscr interface~getmaxyx getmaxyx proc~initscr->interface~getmaxyx interface~f_initscr f_initscr proc~initscr->interface~f_initscr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~initscr~~CalledByGraph proc~initscr initscr program~tetran tetran program~tetran->proc~initscr program~test_key test_key program~test_key->proc~initscr program~test_menu test_menu program~test_menu->proc~initscr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/initscr.html"},{"title":"addch – Tetran","text":"public subroutine addch(ch) Arguments Type Intent Optional Attributes Name character(kind=c_char), intent(in), value :: ch Calls proc~~addch~~CallsGraph proc~addch addch interface~f_addch f_addch proc~addch->interface~f_addch Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/addch.html"},{"title":"f_initscr – Tetran","text":"interface Called by interface~~f_initscr~~CalledByGraph interface~f_initscr f_initscr proc~initscr initscr proc~initscr->interface~f_initscr program~tetran tetran program~tetran->proc~initscr program~test_key test_key program~test_key->proc~initscr program~test_menu test_menu program~test_menu->proc~initscr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public function f_initscr() result(initscr__OUT) bind(C, name='initscr') Arguments None Return Value type(c_ptr)","tags":"","loc":"interface/f_initscr.html"},{"title":"getch – Tetran","text":"interface Called by interface~~getch~~CalledByGraph interface~getch getch proc~title title proc~title->interface~getch proc~key_input key_input proc~key_input->interface~getch program~test_key test_key program~test_key->interface~getch program~tetran tetran program~tetran->proc~title program~test_menu test_menu program~test_menu->proc~title proc~main main proc~main->proc~key_input Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public function getch() result(ch) bind(C) Arguments None Return Value integer(kind=c_int)","tags":"","loc":"interface/getch.html"},{"title":"f_addch – Tetran","text":"interface Called by interface~~f_addch~~CalledByGraph interface~f_addch f_addch proc~addch addch proc~addch->interface~f_addch Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public function f_addch(ch) result(addch__OUT) bind(c, name='addch') Arguments Type Intent Optional Attributes Name character(kind=c_char), intent(in), value :: ch Return Value integer(kind=c_int)","tags":"","loc":"interface/f_addch.html"},{"title":"getmaxyx – Tetran","text":"interface Called by interface~~getmaxyx~~CalledByGraph interface~getmaxyx getmaxyx proc~initscr initscr proc~initscr->interface~getmaxyx program~tetran tetran program~tetran->proc~initscr program~test_key test_key program~test_key->proc~initscr program~test_menu test_menu program~test_menu->proc~initscr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine getmaxyx(win, y, x) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: win integer(kind=c_int) :: y integer(kind=c_int) :: x","tags":"","loc":"interface/getmaxyx.html"},{"title":"endwin – Tetran","text":"interface Called by interface~~endwin~~CalledByGraph interface~endwin endwin program~test_menu test_menu program~test_menu->interface~endwin proc~err err proc~err->interface~endwin proc~game_over game_over proc~game_over->interface~endwin proc~draw_screen draw_screen proc~draw_screen->proc~err proc~freeze freeze proc~freeze->proc~game_over proc~key_input key_input proc~key_input->proc~game_over proc~redraw redraw proc~redraw->proc~draw_screen proc~main main proc~main->proc~freeze proc~main->proc~key_input Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine endwin() bind(C) Arguments None","tags":"","loc":"interface/endwin.html"},{"title":"flushinp – Tetran","text":"interface Called by interface~~flushinp~~CalledByGraph interface~flushinp flushinp proc~key_input key_input proc~key_input->interface~flushinp proc~main main proc~main->proc~key_input Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine flushinp() bind(c) Arguments None","tags":"","loc":"interface/flushinp.html"},{"title":"timeout – Tetran","text":"interface Called by interface~~timeout~~CalledByGraph interface~timeout timeout program~tetran tetran program~tetran->interface~timeout proc~title title program~tetran->proc~title proc~title->interface~timeout program~test_menu test_menu program~test_menu->proc~title Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine timeout(delay) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: delay","tags":"","loc":"interface/timeout.html"},{"title":"mvaddch – Tetran","text":"interface Called by interface~~mvaddch~~CalledByGraph interface~mvaddch mvaddch proc~draw_screen draw_screen proc~draw_screen->interface~mvaddch proc~draw_piece draw_piece proc~draw_piece->interface~mvaddch proc~redraw redraw proc~redraw->proc~draw_screen proc~redraw->proc~draw_piece proc~dissolve dissolve proc~dissolve->proc~draw_piece proc~makeletter makeLetter proc~makeletter->proc~draw_piece proc~title title proc~title->proc~dissolve proc~title->proc~makeletter program~tetran tetran program~tetran->proc~title program~test_menu test_menu program~test_menu->proc~title Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine mvaddch(y, x, ch) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: y integer(kind=c_int), intent(in), value :: x character(kind=c_char), intent(in), value :: ch","tags":"","loc":"interface/mvaddch.html"},{"title":"refresh – Tetran","text":"interface Called by interface~~refresh~~CalledByGraph interface~refresh refresh proc~title title proc~title->interface~refresh program~tetran tetran program~tetran->proc~title program~test_menu test_menu program~test_menu->proc~title Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine refresh() bind(C, name=\"0\") Arguments None","tags":"","loc":"interface/refresh.html"},{"title":"clear – Tetran","text":"interface Called by interface~~clear~~CalledByGraph interface~clear clear program~tetran tetran program~tetran->interface~clear proc~title title program~tetran->proc~title proc~title->interface~clear program~test_menu test_menu program~test_menu->proc~title Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine clear() bind(C) Arguments None","tags":"","loc":"interface/clear.html"},{"title":"noecho – Tetran","text":"interface Called by interface~~noecho~~CalledByGraph interface~noecho noecho program~tetran tetran program~tetran->interface~noecho proc~title title program~tetran->proc~title proc~title->interface~noecho program~test_menu test_menu program~test_menu->proc~title Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine noecho() bind(C) Arguments None","tags":"","loc":"interface/noecho.html"},{"title":"cbreak – Tetran","text":"interface Called by interface~~cbreak~~CalledByGraph interface~cbreak cbreak program~tetran tetran program~tetran->interface~cbreak proc~title title program~tetran->proc~title proc~title->interface~cbreak program~test_menu test_menu program~test_menu->proc~title Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine cbreak() bind(C) Arguments None","tags":"","loc":"interface/cbreak.html"},{"title":"mvprintw – Tetran","text":"interface Called by interface~~mvprintw~~CalledByGraph interface~mvprintw mvprintw proc~draw_score draw_score proc~draw_score->interface~mvprintw proc~redraw redraw proc~redraw->proc~draw_score Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine mvprintw(y, x, str) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: y integer(kind=c_int), intent(in), value :: x character(kind=c_char), intent(in) :: str","tags":"","loc":"interface/mvprintw.html"},{"title":"usleep – Tetran","text":"interface Called by interface~~usleep~~CalledByGraph interface~usleep usleep proc~title title proc~title->interface~usleep program~test_key test_key program~test_key->interface~usleep program~tetran tetran program~tetran->proc~title program~test_menu test_menu program~test_menu->proc~title Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public subroutine usleep(time) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: time","tags":"","loc":"interface/usleep.html"},{"title":"key_input – Tetran","text":"public subroutine key_input(F, P, NP) Arguments Type Intent Optional Attributes Name class( Field ), intent(inout) :: F class( Piece ), intent(inout) :: P class( Piece ), intent(inout), optional :: NP Calls proc~~key_input~~CallsGraph proc~key_input key_input interface~flushinp flushinp proc~key_input->interface~flushinp proc~game_over game_over proc~key_input->proc~game_over proc~ai_input AI_input proc~key_input->proc~ai_input interface~getch getch proc~key_input->interface~getch interface~endwin endwin proc~game_over->interface~endwin proc~project_down project_down proc~ai_input->proc~project_down proc~seek_deep seek_deep proc~ai_input->proc~seek_deep proc~down_random down_random proc~ai_input->proc~down_random proc~move_random move_random proc~seek_deep->proc~move_random proc~height height proc~seek_deep->proc~height proc~height->proc~project_down Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~key_input~~CalledByGraph proc~key_input key_input proc~main main proc~main->proc~key_input Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/key_input.html"},{"title":"draw_piece – Tetran","text":"public subroutine draw_piece(P) Arguments Type Intent Optional Attributes Name class( Piece ), intent(in) :: P Calls proc~~draw_piece~~CallsGraph proc~draw_piece draw_piece interface~mvaddch mvaddch proc~draw_piece->interface~mvaddch Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~draw_piece~~CalledByGraph proc~draw_piece draw_piece proc~redraw redraw proc~redraw->proc~draw_piece proc~dissolve dissolve proc~dissolve->proc~draw_piece proc~makeletter makeLetter proc~makeletter->proc~draw_piece proc~title title proc~title->proc~dissolve proc~title->proc~makeletter program~tetran tetran program~tetran->proc~title program~test_menu test_menu program~test_menu->proc~title Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/draw_piece.html"},{"title":"freeze – Tetran","text":"public subroutine freeze(F, P, NP) Arguments Type Intent Optional Attributes Name class( Field ), intent(inout) :: F class( Piece ), intent(inout) :: P class( Piece ), intent(inout) :: NP Calls proc~~freeze~~CallsGraph proc~freeze freeze proc~game_over game_over proc~freeze->proc~game_over interface~endwin endwin proc~game_over->interface~endwin Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~freeze~~CalledByGraph proc~freeze freeze proc~main main proc~main->proc~freeze Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/freeze.html"},{"title":"game_over – Tetran","text":"public subroutine game_over(F, P, msg) Arguments Type Intent Optional Attributes Name class( Field ), intent(in) :: F class( Piece ), intent(in), optional :: P character(len=*), intent(in), optional :: msg Calls proc~~game_over~~CallsGraph proc~game_over game_over interface~endwin endwin proc~game_over->interface~endwin Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~game_over~~CalledByGraph proc~game_over game_over proc~freeze freeze proc~freeze->proc~game_over proc~key_input key_input proc~key_input->proc~game_over proc~main main proc~main->proc~freeze proc~main->proc~key_input Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/game_over.html"},{"title":"err – Tetran","text":"public subroutine err(msg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: msg Calls proc~~err~~CallsGraph proc~err err interface~endwin endwin proc~err->interface~endwin Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~err~~CalledByGraph proc~err err proc~draw_screen draw_screen proc~draw_screen->proc~err proc~redraw redraw proc~redraw->proc~draw_screen Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/err.html"},{"title":"setup – Tetran","text":"private subroutine setup(self, W, H, x0, AI, difffact, debug) Arguments Type Intent Optional Attributes Name class( Field ), intent(inout) :: self integer, intent(in) :: W integer, intent(in) :: H integer, intent(in), optional :: x0 logical, intent(in), optional :: AI real, intent(in), optional :: difffact logical, intent(in), optional :: debug Contents None","tags":"","loc":"proc/setup.html"},{"title":"levelup – Tetran","text":"private subroutine levelup(self) Arguments Type Intent Optional Attributes Name class( Field ), intent(inout) :: self Contents None","tags":"","loc":"proc/levelup.html"},{"title":"clear_lines – Tetran","text":"private subroutine clear_lines(self) Arguments Type Intent Optional Attributes Name class( Field ), intent(inout) :: self Contents None","tags":"","loc":"proc/clear_lines.html"},{"title":"makeLetter – Tetran","text":"public function makeLetter(F, y0, x0, letter) result(S) Arguments Type Intent Optional Attributes Name type( Field ), intent(in) :: F integer(kind=c_int), intent(in) :: y0 integer(kind=c_int), intent(in) :: x0 character, intent(in) :: letter Return Value type( Piece ) Calls proc~~makeletter~~CallsGraph proc~makeletter makeLetter proc~draw_piece draw_piece proc~makeletter->proc~draw_piece interface~mvaddch mvaddch proc~draw_piece->interface~mvaddch Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~makeletter~~CalledByGraph proc~makeletter makeLetter proc~title title proc~title->proc~makeletter program~tetran tetran program~tetran->proc~title program~test_menu test_menu program~test_menu->proc~title Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/makeletter.html"},{"title":"title – Tetran","text":"public subroutine title(Fld) Arguments Type Intent Optional Attributes Name class( Field ), intent(in), optional :: Fld Calls proc~~title~~CallsGraph proc~title title proc~makeletter makeLetter proc~title->proc~makeletter interface~refresh refresh proc~title->interface~refresh interface~usleep usleep proc~title->interface~usleep proc~dissolve dissolve proc~title->proc~dissolve interface~noecho noecho proc~title->interface~noecho interface~timeout timeout proc~title->interface~timeout interface~getch getch proc~title->interface~getch interface~cbreak cbreak proc~title->interface~cbreak interface~clear clear proc~title->interface~clear proc~draw_piece draw_piece proc~makeletter->proc~draw_piece proc~randint randint proc~dissolve->proc~randint proc~dissolve->proc~draw_piece interface~mvaddch mvaddch proc~draw_piece->interface~mvaddch Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~title~~CalledByGraph proc~title title program~tetran tetran program~tetran->proc~title program~test_menu test_menu program~test_menu->proc~title Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/title.html"},{"title":"dissolve – Tetran","text":"public recursive subroutine dissolve(P) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: P Calls proc~~dissolve~~CallsGraph proc~dissolve dissolve proc~randint randint proc~dissolve->proc~randint proc~draw_piece draw_piece proc~dissolve->proc~draw_piece interface~mvaddch mvaddch proc~draw_piece->interface~mvaddch Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~dissolve~~CalledByGraph proc~dissolve dissolve proc~title title proc~title->proc~dissolve program~tetran tetran program~tetran->proc~title program~test_menu test_menu program~test_menu->proc~title Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/dissolve.html"},{"title":"main – Tetran","text":"subroutine main(F, P, NP) time's up, move piece one step down. real(trate) is necessary for float time comparison! Arguments Type Intent Optional Attributes Name class( Field ) :: F type( Piece ) :: P type( Piece ) :: NP Calls proc~~main~~CallsGraph proc~main main proc~freeze freeze proc~main->proc~freeze proc~key_input key_input proc~main->proc~key_input proc~game_over game_over proc~freeze->proc~game_over interface~getch getch proc~key_input->interface~getch interface~flushinp flushinp proc~key_input->interface~flushinp proc~ai_input AI_input proc~key_input->proc~ai_input proc~key_input->proc~game_over proc~project_down project_down proc~ai_input->proc~project_down proc~seek_deep seek_deep proc~ai_input->proc~seek_deep proc~down_random down_random proc~ai_input->proc~down_random interface~endwin endwin proc~game_over->interface~endwin proc~move_random move_random proc~seek_deep->proc~move_random proc~height height proc~seek_deep->proc~height proc~height->proc~project_down Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/main.html"},{"title":"redraw – Tetran","text":"subroutine redraw(F, P, NP) Arguments Type Intent Optional Attributes Name class( Field ), intent(in) :: F class( Piece ), intent(in) :: P class( Piece ), intent(in) :: NP Calls proc~~redraw~~CallsGraph proc~redraw redraw proc~draw_screen draw_screen proc~redraw->proc~draw_screen proc~draw_piece draw_piece proc~redraw->proc~draw_piece proc~draw_score draw_score proc~redraw->proc~draw_score proc~err err proc~draw_screen->proc~err interface~mvaddch mvaddch proc~draw_screen->interface~mvaddch proc~draw_piece->interface~mvaddch interface~mvprintw mvprintw proc~draw_score->interface~mvprintw interface~endwin endwin proc~err->interface~endwin Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/redraw.html"},{"title":"cmd_parse – Tetran","text":"subroutine cmd_parse(W, H, difffact, players, debug) Arguments Type Intent Optional Attributes Name integer, intent(out) :: W integer, intent(out) :: H real, intent(out) :: difffact integer, intent(out) :: players logical, intent(out) :: debug Calls proc~~cmd_parse~~CallsGraph proc~cmd_parse cmd_parse proc~randint randint proc~cmd_parse->proc~randint Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~cmd_parse~~CalledByGraph proc~cmd_parse cmd_parse program~tetran tetran program~tetran->proc~cmd_parse Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/cmd_parse.html"},{"title":"draw_screen – Tetran","text":"subroutine draw_screen(F) Arguments Type Intent Optional Attributes Name class( Field ), intent(in) :: F Calls proc~~draw_screen~~CallsGraph proc~draw_screen draw_screen proc~err err proc~draw_screen->proc~err interface~mvaddch mvaddch proc~draw_screen->interface~mvaddch interface~endwin endwin proc~err->interface~endwin Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~draw_screen~~CalledByGraph proc~draw_screen draw_screen proc~redraw redraw proc~redraw->proc~draw_screen Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/draw_screen.html"},{"title":"draw_score – Tetran","text":"subroutine draw_score(F) Arguments Type Intent Optional Attributes Name class( Field ), intent(in) :: F Calls proc~~draw_score~~CallsGraph proc~draw_score draw_score interface~mvprintw mvprintw proc~draw_score->interface~mvprintw Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~draw_score~~CalledByGraph proc~draw_score draw_score proc~redraw redraw proc~redraw->proc~draw_score Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/draw_score.html"},{"title":"initial – Tetran","text":"function initial(next) result(failed) Arguments Type Intent Optional Attributes Name character, intent(in) :: next Return Value logical Calls proc~~initial~~CallsGraph proc~initial initial proc~print_piece print_piece proc~initial->proc~print_piece proc~print_block print_block proc~print_piece->proc~print_block Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~initial~~CalledByGraph proc~initial initial program~motiontest motiontest program~motiontest->proc~initial Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/initial.html"},{"title":"test_floor – Tetran","text":"function test_floor(next) result(failed) Arguments Type Intent Optional Attributes Name character, intent(in) :: next Return Value logical Called by proc~~test_floor~~CalledByGraph proc~test_floor test_floor program~motiontest motiontest program~motiontest->proc~test_floor Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/test_floor.html"},{"title":"left_wall – Tetran","text":"function left_wall(next) result(failed) Arguments Type Intent Optional Attributes Name character, intent(in) :: next Return Value logical Called by proc~~left_wall~~CalledByGraph proc~left_wall left_wall program~motiontest motiontest program~motiontest->proc~left_wall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/left_wall.html"},{"title":"right_wall – Tetran","text":"function right_wall(next) result(failed) Arguments Type Intent Optional Attributes Name character, intent(in) :: next Return Value logical Called by proc~~right_wall~~CalledByGraph proc~right_wall right_wall program~motiontest motiontest program~motiontest->proc~right_wall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/right_wall.html"},{"title":"block_hit – Tetran","text":"function block_hit(next) result(failed) Arguments Type Intent Optional Attributes Name character, intent(in) :: next Return Value logical Called by proc~~block_hit~~CalledByGraph proc~block_hit block_hit program~motiontest motiontest program~motiontest->proc~block_hit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/block_hit.html"},{"title":"print_piece – Tetran","text":"subroutine print_piece(P) Arguments Type Intent Optional Attributes Name class( Piece ), intent(in) :: P Calls proc~~print_piece~~CallsGraph proc~print_piece print_piece proc~print_block print_block proc~print_piece->proc~print_block Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~print_piece~~CalledByGraph proc~print_piece print_piece proc~initial initial proc~initial->proc~print_piece program~motiontest motiontest program~motiontest->proc~initial Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/print_piece.html"},{"title":"print_block – Tetran","text":"subroutine print_block(B) Arguments Type Intent Optional Attributes Name integer, intent(in) :: B (:,:) Called by proc~~print_block~~CalledByGraph proc~print_block print_block proc~print_piece print_piece proc~print_piece->proc~print_block proc~initial initial proc~initial->proc~print_piece program~motiontest motiontest program~motiontest->proc~initial Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/print_block.html"},{"title":"check_x – Tetran","text":"subroutine check_x(x) Arguments Type Intent Optional Attributes Name integer, intent(in) :: x (:) Calls proc~~check_x~~CallsGraph proc~check_x check_x proc~err~2 err proc~check_x->proc~err~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~check_x~~CalledByGraph proc~check_x check_x program~testshapes testshapes program~testshapes->proc~check_x Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/check_x.html"},{"title":"err – Tetran","text":"subroutine err(msg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: msg Called by proc~~err~2~~CalledByGraph proc~err~2 err program~testshapes testshapes program~testshapes->proc~err~2 proc~check_x check_x program~testshapes->proc~check_x proc~check_x->proc~err~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/err~2.html"},{"title":"random_init – Tetran","text":"module procedure random_init module procedure random_init() Arguments None Calls proc~~random_init~2~~CallsGraph proc~random_init~2 random_init proc~randint randint proc~random_init~2->proc~randint Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/random_init~2.html"},{"title":"random – Tetran","text":"Uses iso_fortran_env module~~random~~UsesGraph module~random random iso_fortran_env iso_fortran_env module~random->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by Descendants: rand rand module~~random~~UsedByGraph module~random random program~testshapes testshapes program~testshapes->module~random module~shapes shapes program~testshapes->module~shapes module~rand rand module~rand->module~random module~shapes->module~random module~rand~2 rand module~rand~2->module~random module~menu menu module~menu->module~random module~menu->module~shapes module~blocks blocks module~menu->module~blocks program~tetran tetran program~tetran->module~random program~tetran->module~shapes program~tetran->module~menu program~tetran->module~blocks module~keys keys program~tetran->module~keys program~randblock randblock program~randblock->module~random program~randblock->module~shapes program~test_menu test_menu program~test_menu->module~menu program~motiontest motiontest program~motiontest->module~shapes module~ai AI module~ai->module~shapes module~blocks->module~shapes module~keys->module~shapes module~keys->module~ai module~keys->module~blocks Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces std mean Functions randint std_real std_int mean_real mean_int Subroutines random_init Interfaces public interface std public pure function std_int (A) result(std) Arguments Type Intent Optional Attributes Name integer, intent(in) :: A (:) Return Value real public pure function std_real (A) result(std) Arguments Type Intent Optional Attributes Name real, intent(in) :: A (:) Return Value real public interface mean public pure function mean_int (A) result(mean) Arguments Type Intent Optional Attributes Name integer, intent(in) :: A (:) Return Value real public pure function mean_real (A) result(mean) Arguments Type Intent Optional Attributes Name real, intent(in) :: A (:) Return Value real Functions public impure elemental function randint (lo, hi) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lo integer, intent(in) :: hi Return Value integer public pure function std_real (A) result(std) Arguments Type Intent Optional Attributes Name real, intent(in) :: A (:) Return Value real public pure function std_int (A) result(std) Arguments Type Intent Optional Attributes Name integer, intent(in) :: A (:) Return Value real public pure function mean_real (A) result(mean) Arguments Type Intent Optional Attributes Name real, intent(in) :: A (:) Return Value real public pure function mean_int (A) result(mean) Arguments Type Intent Optional Attributes Name integer, intent(in) :: A (:) Return Value real Subroutines public subroutine random_init () Arguments None","tags":"","loc":"module/random.html"},{"title":"AI – Tetran","text":"Uses fields shapes module~~ai~~UsesGraph module~ai AI module~shapes shapes module~ai->module~shapes module~fields fields module~ai->module~fields module~shapes->module~fields module~rotflip rotflip module~shapes->module~rotflip module~random random module~shapes->module~random iso_fortran_env iso_fortran_env module~shapes->iso_fortran_env iso_c_binding iso_c_binding module~fields->iso_c_binding module~rotflip->iso_fortran_env module~random->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~ai~~UsedByGraph module~ai AI module~keys keys module~keys->module~ai program~tetran tetran program~tetran->module~keys Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions project_down height diff Subroutines AI_input seek_deep down_random move_random Functions public function project_down (F, P) result(y) Arguments Type Intent Optional Attributes Name class( Field ), intent(in) :: F class( Piece ), intent(in) :: P Return Value integer public function height (F, P) Arguments Type Intent Optional Attributes Name class( Field ), intent(in) :: F class( Piece ), intent(in) :: P Return Value integer public pure function diff (A) Arguments Type Intent Optional Attributes Name integer, intent(in) :: A (:) Return Value integer Subroutines public subroutine AI_input (F, P) Arguments Type Intent Optional Attributes Name class( Field ), intent(in) :: F class( Piece ), intent(inout) :: P public subroutine seek_deep (F, P) Arguments Type Intent Optional Attributes Name class( Field ), intent(in) :: F class( Piece ), intent(inout) :: P public subroutine down_random (P) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: P public subroutine move_random (P) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: P","tags":"","loc":"module/ai.html"},{"title":"rotflip – Tetran","text":"Uses iso_fortran_env module~~rotflip~~UsesGraph module~rotflip rotflip iso_fortran_env iso_fortran_env module~rotflip->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~rotflip~~UsedByGraph module~rotflip rotflip module~shapes shapes module~shapes->module~rotflip program~testshapes testshapes program~testshapes->module~shapes module~keys keys module~keys->module~shapes module~ai AI module~keys->module~ai module~blocks blocks module~keys->module~blocks program~motiontest motiontest program~motiontest->module~shapes module~ai->module~shapes module~menu menu module~menu->module~shapes module~menu->module~blocks module~blocks->module~shapes program~tetran tetran program~tetran->module~shapes program~tetran->module~keys program~tetran->module~menu program~tetran->module~blocks program~randblock randblock program~randblock->module~shapes program~test_menu test_menu program~test_menu->module~menu Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions rot90 flip flipud fliplr Functions public function rot90 (A, k) Arguments Type Intent Optional Attributes Name integer, intent(in) :: A (:,:) integer, intent(in), optional :: k Return Value integer public function flip (A, d) Arguments Type Intent Optional Attributes Name integer, intent(in) :: A (:,:) integer, intent(in) :: d Return Value integer public function flipud (A) Arguments Type Intent Optional Attributes Name integer, intent(in) :: A (:,:) Return Value integer public function fliplr (A) Arguments Type Intent Optional Attributes Name integer, intent(in) :: A (:,:) Return Value integer","tags":"","loc":"module/rotflip.html"},{"title":"shapes – Tetran","text":"Uses iso_fortran_env rotflip fields random module~~shapes~~UsesGraph module~shapes shapes module~rotflip rotflip module~shapes->module~rotflip module~random random module~shapes->module~random module~fields fields module~shapes->module~fields iso_fortran_env iso_fortran_env module~shapes->iso_fortran_env module~rotflip->iso_fortran_env module~random->iso_fortran_env iso_c_binding iso_c_binding module~fields->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~shapes~~UsedByGraph module~shapes shapes program~testshapes testshapes program~testshapes->module~shapes module~keys keys module~keys->module~shapes module~ai AI module~keys->module~ai module~blocks blocks module~keys->module~blocks program~motiontest motiontest program~motiontest->module~shapes module~ai->module~shapes module~menu menu module~menu->module~shapes module~menu->module~blocks module~blocks->module~shapes program~tetran tetran program~tetran->module~shapes program~tetran->module~keys program~tetran->module~menu program~tetran->module~blocks program~randblock randblock program~randblock->module~shapes program~test_menu test_menu program~test_menu->module~menu Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types Piece Functions gen_type check_collision hit_floor hit_horiz hit_block randomx Subroutines init_block spawn_block dissolver move_left move_right move_down rotate vertflip horizflip tell_why Derived Types type, public, extends( Field ) :: Piece Components Type Visibility Attributes Name Initial real, public :: move_time = 0.5 integer(kind=c_int), public :: sleep_incr = 50000 real, public :: difffact = 1. integer, public :: level = 1 real, public :: diffinc = 1.2 integer, public :: score = 0 integer, public :: Nblock = 0 integer, public :: Ncleared = 0 integer, public :: lines_per_level = 10 integer, public :: bonus (-1:4) = [-100, 0, 40, 100, 300, 1200] character(len=1), public :: blockseq (10000) = \"\" integer, public :: toc integer, public :: tic integer, public :: H integer, public :: W integer, public :: x0 integer, public, allocatable :: screen (:,:) logical, public :: debug = .false. integer, public :: udbg logical, public :: newhit = .false. logical, public :: cheat = .false. logical, public :: AI character, public :: btype character(len=80), public :: why character, public :: ch (12) integer, public :: Nx integer, public :: Ny integer, public :: x integer, public :: y integer, public, allocatable :: values (:,:) logical, public :: landed logical, public :: movereq Type-Bound Procedures procedure, public :: setup procedure, public :: levelup procedure, public :: clear_lines procedure, public :: init => init_block procedure, private :: init_block procedure, public :: check_collision procedure, public :: move_right procedure, public :: move_left procedure, public :: rotate procedure, public :: move_down procedure, public :: dissolver procedure, public :: spawn_block procedure, public :: vertflip procedure, public :: horizflip procedure, private :: randomx procedure, private :: tell_why procedure, private :: hit_horiz procedure, private :: hit_floor procedure, private :: hit_block Functions public function gen_type () result(next) Arguments None Return Value character private function check_collision (self) result(collided) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self Return Value logical private function hit_floor (self) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self Return Value logical private function hit_horiz (self) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self Return Value logical private function hit_block (self) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self Return Value logical private function randomx (self) Arguments Type Intent Optional Attributes Name class( Piece ), intent(in) :: self Return Value integer Subroutines private subroutine init_block (self, F, btype, x, y) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self class( Field ), intent(in) :: F character, intent(in), optional :: btype integer, intent(in), optional :: x integer, intent(in), optional :: y private subroutine spawn_block (self, F, NP) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self class( Field ), intent(inout) :: F class( Piece ), intent(inout), optional :: NP private subroutine dissolver (self) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self private subroutine move_left (self, slam) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self logical, intent(in), optional :: slam private subroutine move_right (self, slam) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self logical, intent(in), optional :: slam private recursive subroutine move_down (self, slam) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self logical, intent(in), optional :: slam private subroutine rotate (self) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self private subroutine vertflip (self) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self private subroutine horizflip (self) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: self private subroutine tell_why (self, msg) Arguments Type Intent Optional Attributes Name class( Piece ), intent(in) :: self character(len=*), intent(in), optional :: msg","tags":"","loc":"module/shapes.html"},{"title":"cinter – Tetran","text":"Uses iso_c_binding module~~cinter~~UsesGraph module~cinter cinter iso_c_binding iso_c_binding module~cinter->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~cinter~~UsedByGraph module~cinter cinter module~errs errs module~errs->module~cinter program~tetran tetran program~tetran->module~cinter program~tetran->module~errs module~keys keys program~tetran->module~keys module~menu menu program~tetran->module~menu module~blocks blocks program~tetran->module~blocks module~keys->module~cinter module~keys->module~blocks program~test_key test_key program~test_key->module~cinter program~test_key->module~errs module~menu->module~cinter module~menu->module~blocks module~blocks->module~cinter program~test_menu test_menu program~test_menu->module~cinter program~test_menu->module~menu Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables LINES COLS stdscr curscr FAIL Interfaces f_initscr getch f_addch getmaxyx endwin flushinp timeout mvaddch refresh clear noecho cbreak mvprintw usleep Functions initscr Subroutines addch Variables Type Visibility Attributes Name Initial integer(kind=c_int), public :: LINES integer(kind=c_int), public :: COLS type(c_ptr), public :: stdscr type(c_ptr), public :: curscr integer(kind=c_int), public, parameter :: FAIL = -1 Interfaces interface public function f_initscr() result(initscr__OUT) bind(C, name='initscr') Arguments None Return Value type(c_ptr) interface public function getch() result(ch) bind(C) Arguments None Return Value integer(kind=c_int) interface public function f_addch(ch) result(addch__OUT) bind(c, name='addch') Arguments Type Intent Optional Attributes Name character(kind=c_char), intent(in), value :: ch Return Value integer(kind=c_int) interface public subroutine getmaxyx(win, y, x) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: win integer(kind=c_int) :: y integer(kind=c_int) :: x interface public subroutine endwin() bind(C) Arguments None interface public subroutine flushinp() bind(c) Arguments None interface public subroutine timeout(delay) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: delay interface public subroutine mvaddch(y, x, ch) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: y integer(kind=c_int), intent(in), value :: x character(kind=c_char), intent(in), value :: ch interface public subroutine refresh() bind(C, name=\"0\") Arguments None interface public subroutine clear() bind(C) Arguments None interface public subroutine noecho() bind(C) Arguments None interface public subroutine cbreak() bind(C) Arguments None interface public subroutine mvprintw(y, x, str) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: y integer(kind=c_int), intent(in), value :: x character(kind=c_char), intent(in) :: str interface public subroutine usleep(time) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: time Functions public function initscr () result(stdscr__OUT) Arguments None Return Value type(C_PTR) Subroutines public subroutine addch (ch) Arguments Type Intent Optional Attributes Name character(kind=c_char), intent(in), value :: ch","tags":"","loc":"module/cinter.html"},{"title":"keys – Tetran","text":"Uses AI cinter blocks shapes fields module~~keys~~UsesGraph module~keys keys module~fields fields module~keys->module~fields module~cinter cinter module~keys->module~cinter module~ai AI module~keys->module~ai module~shapes shapes module~keys->module~shapes module~blocks blocks module~keys->module~blocks iso_c_binding iso_c_binding module~fields->iso_c_binding module~cinter->iso_c_binding module~ai->module~fields module~ai->module~shapes module~shapes->module~fields module~random random module~shapes->module~random module~rotflip rotflip module~shapes->module~rotflip iso_fortran_env iso_fortran_env module~shapes->iso_fortran_env module~blocks->module~fields module~blocks->module~cinter module~blocks->module~shapes module~random->iso_fortran_env module~rotflip->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~keys~~UsedByGraph module~keys keys program~tetran tetran program~tetran->module~keys Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines key_input Subroutines public subroutine key_input (F, P, NP) Arguments Type Intent Optional Attributes Name class( Field ), intent(inout) :: F class( Piece ), intent(inout) :: P class( Piece ), intent(inout), optional :: NP","tags":"","loc":"module/keys.html"},{"title":"blocks – Tetran","text":"Uses cinter shapes fields module~~blocks~~UsesGraph module~blocks blocks module~cinter cinter module~blocks->module~cinter module~shapes shapes module~blocks->module~shapes module~fields fields module~blocks->module~fields iso_c_binding iso_c_binding module~cinter->iso_c_binding module~shapes->module~fields module~random random module~shapes->module~random module~rotflip rotflip module~shapes->module~rotflip iso_fortran_env iso_fortran_env module~shapes->iso_fortran_env module~fields->iso_c_binding module~random->iso_fortran_env module~rotflip->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~blocks~~UsedByGraph module~blocks blocks module~keys keys module~keys->module~blocks program~tetran tetran program~tetran->module~blocks program~tetran->module~keys module~menu menu program~tetran->module~menu module~menu->module~blocks program~test_menu test_menu program~test_menu->module~menu Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines draw_piece freeze game_over Subroutines public subroutine draw_piece (P) Arguments Type Intent Optional Attributes Name class( Piece ), intent(in) :: P public subroutine freeze (F, P, NP) Arguments Type Intent Optional Attributes Name class( Field ), intent(inout) :: F class( Piece ), intent(inout) :: P class( Piece ), intent(inout) :: NP public subroutine game_over (F, P, msg) Arguments Type Intent Optional Attributes Name class( Field ), intent(in) :: F class( Piece ), intent(in), optional :: P character(len=*), intent(in), optional :: msg","tags":"","loc":"module/blocks.html"},{"title":"errs – Tetran","text":"Uses iso_fortran_env cinter module~~errs~~UsesGraph module~errs errs module~cinter cinter module~errs->module~cinter iso_fortran_env iso_fortran_env module~errs->iso_fortran_env iso_c_binding iso_c_binding module~cinter->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~errs~~UsedByGraph module~errs errs program~tetran tetran program~tetran->module~errs program~test_key test_key program~test_key->module~errs Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines err Subroutines public subroutine err (msg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: msg","tags":"","loc":"module/errs.html"},{"title":"fields – Tetran","text":"Uses iso_c_binding module~~fields~~UsesGraph module~fields fields iso_c_binding iso_c_binding module~fields->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~fields~~UsedByGraph module~fields fields program~testshapes testshapes program~testshapes->module~fields module~shapes shapes program~testshapes->module~shapes module~keys keys module~keys->module~fields module~ai AI module~keys->module~ai module~keys->module~shapes module~blocks blocks module~keys->module~blocks program~motiontest motiontest program~motiontest->module~fields program~motiontest->module~shapes module~ai->module~fields module~ai->module~shapes module~shapes->module~fields module~menu menu module~menu->module~fields module~menu->module~shapes module~menu->module~blocks module~blocks->module~fields module~blocks->module~shapes program~tetran tetran program~tetran->module~fields program~tetran->module~keys program~tetran->module~shapes program~tetran->module~menu program~tetran->module~blocks program~test_menu test_menu program~test_menu->module~menu program~randblock randblock program~randblock->module~shapes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types Field Subroutines setup levelup clear_lines Derived Types type, public :: Field Components Type Visibility Attributes Name Initial real, public :: move_time = 0.5 integer(kind=c_int), public :: sleep_incr = 50000 real, public :: difffact = 1. integer, public :: level = 1 real, public :: diffinc = 1.2 integer, public :: score = 0 integer, public :: Nblock = 0 integer, public :: Ncleared = 0 integer, public :: lines_per_level = 10 integer, public :: bonus (-1:4) = [-100, 0, 40, 100, 300, 1200] character(len=1), public :: blockseq (10000) = \"\" integer, public :: toc integer, public :: tic integer, public :: H integer, public :: W integer, public :: x0 integer, public, allocatable :: screen (:,:) logical, public :: debug = .false. integer, public :: udbg logical, public :: newhit = .false. logical, public :: cheat = .false. logical, public :: AI Type-Bound Procedures procedure, public :: setup procedure, public :: levelup procedure, public :: clear_lines Subroutines private subroutine setup (self, W, H, x0, AI, difffact, debug) Arguments Type Intent Optional Attributes Name class( Field ), intent(inout) :: self integer, intent(in) :: W integer, intent(in) :: H integer, intent(in), optional :: x0 logical, intent(in), optional :: AI real, intent(in), optional :: difffact logical, intent(in), optional :: debug private subroutine levelup (self) Arguments Type Intent Optional Attributes Name class( Field ), intent(inout) :: self private subroutine clear_lines (self) Arguments Type Intent Optional Attributes Name class( Field ), intent(inout) :: self","tags":"","loc":"module/fields.html"},{"title":"menu – Tetran","text":"Uses iso_c_binding iso_fortran_env random cinter shapes fields blocks module~~menu~~UsesGraph module~menu menu module~fields fields module~menu->module~fields module~cinter cinter module~menu->module~cinter iso_c_binding iso_c_binding module~menu->iso_c_binding module~random random module~menu->module~random iso_fortran_env iso_fortran_env module~menu->iso_fortran_env module~shapes shapes module~menu->module~shapes module~blocks blocks module~menu->module~blocks module~fields->iso_c_binding module~cinter->iso_c_binding module~random->iso_fortran_env module~shapes->module~fields module~shapes->module~random module~shapes->iso_fortran_env module~rotflip rotflip module~shapes->module~rotflip module~blocks->module~fields module~blocks->module~cinter module~blocks->module~shapes module~rotflip->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~menu~~UsedByGraph module~menu menu program~tetran tetran program~tetran->module~menu program~test_menu test_menu program~test_menu->module~menu Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables buf y0 L W H Functions makeLetter Subroutines title dissolve Variables Type Visibility Attributes Name Initial character(len=10), public :: buf integer(kind=c_int), public, parameter :: y0 = 5 integer(kind=c_int), public, parameter :: L = 10 integer(kind=c_int), public, parameter :: W = 80 integer(kind=c_int), public, parameter :: H = 60 Functions public function makeLetter (F, y0, x0, letter) result(S) Arguments Type Intent Optional Attributes Name type( Field ), intent(in) :: F integer(kind=c_int), intent(in) :: y0 integer(kind=c_int), intent(in) :: x0 character, intent(in) :: letter Return Value type( Piece ) Subroutines public subroutine title (Fld) Arguments Type Intent Optional Attributes Name class( Field ), intent(in), optional :: Fld public recursive subroutine dissolve (P) Arguments Type Intent Optional Attributes Name class( Piece ), intent(inout) :: P","tags":"","loc":"module/menu.html"},{"title":"rand – Tetran","text":"Uses iso_fortran_env Ancestors: random module~~rand~~UsesGraph module~rand rand module~random random module~rand->module~random iso_fortran_env iso_fortran_env module~rand->iso_fortran_env module~random->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Procedures random_init Module Procedures module procedure random_init module procedure random_init() Arguments None","tags":"","loc":"module/rand.html"},{"title":"rand – Tetran","text":"Uses Ancestors: random module~~rand~2~~UsesGraph module~rand~2 rand module~random random module~rand~2->module~random iso_fortran_env iso_fortran_env module~random->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents None","tags":"","loc":"module/rand~2.html"},{"title":"tetran – Tetran","text":"Uses menu cinter errs blocks shapes fields random keys iso_c_binding program~~tetran~~UsesGraph program~tetran tetran module~errs errs program~tetran->module~errs module~fields fields program~tetran->module~fields module~cinter cinter program~tetran->module~cinter iso_c_binding iso_c_binding program~tetran->iso_c_binding module~random random program~tetran->module~random module~shapes shapes program~tetran->module~shapes module~menu menu program~tetran->module~menu module~blocks blocks program~tetran->module~blocks module~keys keys program~tetran->module~keys module~errs->module~cinter iso_fortran_env iso_fortran_env module~errs->iso_fortran_env module~fields->iso_c_binding module~cinter->iso_c_binding module~random->iso_fortran_env module~shapes->module~fields module~shapes->module~random module~rotflip rotflip module~shapes->module~rotflip module~shapes->iso_fortran_env module~menu->module~fields module~menu->module~cinter module~menu->iso_c_binding module~menu->module~random module~menu->module~shapes module~menu->module~blocks module~menu->iso_fortran_env module~blocks->module~fields module~blocks->module~cinter module~blocks->module~shapes module~keys->module~fields module~keys->module~cinter module~keys->module~shapes module~keys->module~blocks module~ai AI module~keys->module~ai module~rotflip->iso_fortran_env module~ai->module~fields module~ai->module~shapes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~tetran~~CallsGraph program~tetran tetran proc~title title program~tetran->proc~title proc~cmd_parse cmd_parse program~tetran->proc~cmd_parse interface~noecho noecho program~tetran->interface~noecho proc~initscr initscr program~tetran->proc~initscr interface~timeout timeout program~tetran->interface~timeout proc~random_init random_init program~tetran->proc~random_init interface~cbreak cbreak program~tetran->interface~cbreak interface~clear clear program~tetran->interface~clear proc~title->interface~noecho proc~title->interface~timeout proc~title->interface~cbreak proc~title->interface~clear proc~makeletter makeLetter proc~title->proc~makeletter interface~refresh refresh proc~title->interface~refresh interface~usleep usleep proc~title->interface~usleep proc~dissolve dissolve proc~title->proc~dissolve interface~getch getch proc~title->interface~getch proc~randint randint proc~cmd_parse->proc~randint interface~f_initscr f_initscr proc~initscr->interface~f_initscr interface~getmaxyx getmaxyx proc~initscr->interface~getmaxyx proc~random_init->proc~randint proc~draw_piece draw_piece proc~makeletter->proc~draw_piece proc~dissolve->proc~randint proc~dissolve->proc~draw_piece interface~mvaddch mvaddch proc~draw_piece->interface~mvaddch Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables stdscr trate difffact W H players i x0 debug update isAI F P NP Subroutines main redraw cmd_parse draw_screen draw_score Variables Type Attributes Name Initial type(c_ptr) :: stdscr integer :: trate real :: difffact integer :: W integer :: H integer :: players integer :: i integer :: x0 (2) logical :: debug logical :: update = .false. logical :: isAI (2) = [.false., .true.] type( Field ) :: F (2) type( Piece ) :: P (2) type( Piece ) :: NP (2) Subroutines subroutine main (F, P, NP) time's up, move piece one step down. real(trate) is necessary for float time comparison! Arguments Type Intent Optional Attributes Name class( Field ) :: F type( Piece ) :: P type( Piece ) :: NP subroutine redraw (F, P, NP) Arguments Type Intent Optional Attributes Name class( Field ), intent(in) :: F class( Piece ), intent(in) :: P class( Piece ), intent(in) :: NP subroutine cmd_parse (W, H, difffact, players, debug) Arguments Type Intent Optional Attributes Name integer, intent(out) :: W integer, intent(out) :: H real, intent(out) :: difffact integer, intent(out) :: players logical, intent(out) :: debug subroutine draw_screen (F) Arguments Type Intent Optional Attributes Name class( Field ), intent(in) :: F subroutine draw_score (F) Arguments Type Intent Optional Attributes Name class( Field ), intent(in) :: F","tags":"","loc":"program/tetran.html"},{"title":"test_key – Tetran","text":"Uses iso_fortran_env iso_c_binding cinter errs program~~test_key~~UsesGraph program~test_key test_key module~cinter cinter program~test_key->module~cinter iso_c_binding iso_c_binding program~test_key->iso_c_binding iso_fortran_env iso_fortran_env program~test_key->iso_fortran_env module~errs errs program~test_key->module~errs module~cinter->iso_c_binding module~errs->module~cinter module~errs->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~test_key~~CallsGraph program~test_key test_key proc~initscr initscr program~test_key->proc~initscr interface~usleep usleep program~test_key->interface~usleep interface~getch getch program~test_key->interface~getch endwin endwin program~test_key->endwin interface~getmaxyx getmaxyx proc~initscr->interface~getmaxyx interface~f_initscr f_initscr proc~initscr->interface~f_initscr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables stdscr ic lastEsc Variables Type Attributes Name Initial type(c_ptr) :: stdscr integer(kind=c_int) :: ic logical :: lastEsc = .false.","tags":"","loc":"program/test_key.html"},{"title":"motiontest – Tetran","text":"Uses iso_fortran_env shapes fields program~~motiontest~~UsesGraph program~motiontest motiontest iso_fortran_env iso_fortran_env program~motiontest->iso_fortran_env module~fields fields program~motiontest->module~fields module~shapes shapes program~motiontest->module~shapes iso_c_binding iso_c_binding module~fields->iso_c_binding module~shapes->iso_fortran_env module~shapes->module~fields module~random random module~shapes->module~random module~rotflip rotflip module~shapes->module~rotflip module~random->iso_fortran_env module~rotflip->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~motiontest~~CallsGraph program~motiontest motiontest proc~test_floor test_floor program~motiontest->proc~test_floor proc~left_wall left_wall program~motiontest->proc~left_wall proc~initial initial program~motiontest->proc~initial proc~right_wall right_wall program~motiontest->proc~right_wall proc~block_hit block_hit program~motiontest->proc~block_hit proc~print_piece print_piece proc~initial->proc~print_piece proc~print_block print_block proc~print_piece->proc~print_block Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables W H failed Functions initial test_floor left_wall right_wall block_hit Subroutines print_piece print_block Variables Type Attributes Name Initial integer, parameter :: W = 10 integer, parameter :: H = 10 logical :: failed = .false. Functions function initial (next) result(failed) Arguments Type Intent Optional Attributes Name character, intent(in) :: next Return Value logical function test_floor (next) result(failed) Arguments Type Intent Optional Attributes Name character, intent(in) :: next Return Value logical function left_wall (next) result(failed) Arguments Type Intent Optional Attributes Name character, intent(in) :: next Return Value logical function right_wall (next) result(failed) Arguments Type Intent Optional Attributes Name character, intent(in) :: next Return Value logical function block_hit (next) result(failed) Arguments Type Intent Optional Attributes Name character, intent(in) :: next Return Value logical Subroutines subroutine print_piece (P) Arguments Type Intent Optional Attributes Name class( Piece ), intent(in) :: P subroutine print_block (B) Arguments Type Intent Optional Attributes Name integer, intent(in) :: B (:,:)","tags":"","loc":"program/motiontest.html"},{"title":"test_menu – Tetran","text":"Uses iso_c_binding cinter menu program~~test_menu~~UsesGraph program~test_menu test_menu module~cinter cinter program~test_menu->module~cinter iso_c_binding iso_c_binding program~test_menu->iso_c_binding module~menu menu program~test_menu->module~menu module~cinter->iso_c_binding module~menu->module~cinter module~menu->iso_c_binding module~fields fields module~menu->module~fields module~random random module~menu->module~random iso_fortran_env iso_fortran_env module~menu->iso_fortran_env module~shapes shapes module~menu->module~shapes module~blocks blocks module~menu->module~blocks module~fields->iso_c_binding module~random->iso_fortran_env module~shapes->module~fields module~shapes->module~random module~shapes->iso_fortran_env module~rotflip rotflip module~shapes->module~rotflip module~blocks->module~cinter module~blocks->module~fields module~blocks->module~shapes module~rotflip->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~test_menu~~CallsGraph program~test_menu test_menu proc~initscr initscr program~test_menu->proc~initscr proc~title title program~test_menu->proc~title interface~endwin endwin program~test_menu->interface~endwin interface~f_initscr f_initscr proc~initscr->interface~f_initscr interface~getmaxyx getmaxyx proc~initscr->interface~getmaxyx interface~refresh refresh proc~title->interface~refresh proc~makeletter makeLetter proc~title->proc~makeletter interface~cbreak cbreak proc~title->interface~cbreak interface~usleep usleep proc~title->interface~usleep proc~dissolve dissolve proc~title->proc~dissolve interface~noecho noecho proc~title->interface~noecho interface~timeout timeout proc~title->interface~timeout interface~getch getch proc~title->interface~getch interface~clear clear proc~title->interface~clear proc~draw_piece draw_piece proc~makeletter->proc~draw_piece proc~randint randint proc~dissolve->proc~randint proc~dissolve->proc~draw_piece interface~mvaddch mvaddch proc~draw_piece->interface~mvaddch Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables stdscr Variables Type Attributes Name Initial type(c_ptr) :: stdscr","tags":"","loc":"program/test_menu.html"},{"title":"randblock – Tetran","text":"Uses iso_fortran_env shapes random program~~randblock~~UsesGraph program~randblock randblock iso_fortran_env iso_fortran_env program~randblock->iso_fortran_env module~random random program~randblock->module~random module~shapes shapes program~randblock->module~shapes module~random->iso_fortran_env module~shapes->iso_fortran_env module~shapes->module~random module~rotflip rotflip module~shapes->module~rotflip module~fields fields module~shapes->module~fields module~rotflip->iso_fortran_env iso_c_binding iso_c_binding module~fields->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~randblock~~CallsGraph program~randblock randblock interface~mean mean program~randblock->interface~mean proc~gen_type gen_type program~randblock->proc~gen_type interface~std std program~randblock->interface~std proc~randint randint program~randblock->proc~randint proc~random_init random_init program~randblock->proc~random_init proc~mean_real mean_real interface~mean->proc~mean_real proc~mean_int mean_int interface~mean->proc~mean_int proc~gen_type->proc~randint proc~std_int std_int interface~std->proc~std_int proc~std_real std_real interface~std->proc~std_real proc~random_init->proc~randint proc~std_int->interface~mean proc~std_real->interface~mean Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables types Ntypes rtol ideal b e f g i n c u buf Variables Type Attributes Name Initial character(len=*), parameter :: types = 'ITLJSZOD' integer, parameter :: Ntypes = len(types) real, parameter :: rtol = 0.01 real :: ideal character, allocatable :: b (:) real, allocatable :: e (:) integer, allocatable :: f (:) integer, allocatable :: g (:) integer :: i integer :: n integer :: c (Ntypes) integer :: u character(len=16) :: buf","tags":"","loc":"program/randblock.html"},{"title":"testshapes – Tetran","text":"Uses iso_fortran_env shapes fields random program~~testshapes~~UsesGraph program~testshapes testshapes iso_fortran_env iso_fortran_env program~testshapes->iso_fortran_env module~random random program~testshapes->module~random module~fields fields program~testshapes->module~fields module~shapes shapes program~testshapes->module~shapes module~random->iso_fortran_env iso_c_binding iso_c_binding module~fields->iso_c_binding module~shapes->iso_fortran_env module~shapes->module~random module~shapes->module~fields module~rotflip rotflip module~shapes->module~rotflip module~rotflip->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~testshapes~~CallsGraph program~testshapes testshapes proc~random_init random_init program~testshapes->proc~random_init proc~check_x check_x program~testshapes->proc~check_x proc~err~2 err program~testshapes->proc~err~2 proc~randint randint proc~random_init->proc~randint proc~check_x->proc~err~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables F S line tee ell jay ess zee oh Ny Nx W H Ntest i xarr Subroutines check_x err Variables Type Attributes Name Initial type( Field ) :: F type( Piece ) :: S type( Piece ) :: line type( Piece ) :: tee type( Piece ) :: ell type( Piece ) :: jay type( Piece ) :: ess type( Piece ) :: zee type( Piece ) :: oh integer, parameter :: Ny = 4 integer, parameter :: Nx = 4 integer, parameter :: W = 6 integer, parameter :: H = 10 integer, parameter :: Ntest = 100 integer :: i integer :: xarr (Ntest) Subroutines subroutine check_x (x) Arguments Type Intent Optional Attributes Name integer, intent(in) :: x (:) subroutine err (msg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: msg","tags":"","loc":"program/testshapes.html"}]}